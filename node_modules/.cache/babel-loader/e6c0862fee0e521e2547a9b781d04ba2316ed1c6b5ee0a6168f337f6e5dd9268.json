{"ast":null,"code":"// 定义常用的可视化效果\n\n// 颜色工具\nexport const getGradientColor = (startColor, endColor, percent) => {\n  // 解析颜色\n  const start = {\n    r: parseInt(startColor.slice(1, 3), 16),\n    g: parseInt(startColor.slice(3, 5), 16),\n    b: parseInt(startColor.slice(5, 7), 16)\n  };\n  const end = {\n    r: parseInt(endColor.slice(1, 3), 16),\n    g: parseInt(endColor.slice(3, 5), 16),\n    b: parseInt(endColor.slice(5, 7), 16)\n  };\n\n  // 计算渐变颜色\n  const r = Math.floor(start.r + percent * (end.r - start.r));\n  const g = Math.floor(start.g + percent * (end.g - start.g));\n  const b = Math.floor(start.b + percent * (end.b - start.b));\n\n  // 转换为十六进制\n  return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n};\n\n// 频谱柱状图\nexport const drawSpectrumBars = (ctx, frequencies, width, height, options = {}) => {\n  const {\n    barWidth = 5,\n    barSpacing = 2,\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    minHeight = 5,\n    maxFreq = frequencies.length * 0.75 // 只显示频率范围的75%，高频部分通常人耳听不到\n  } = options;\n  ctx.clearRect(0, 0, width, height);\n  const totalBars = Math.min(Math.floor(width / (barWidth + barSpacing)), maxFreq);\n  const frequencyStep = Math.floor(frequencies.length / totalBars);\n  for (let i = 0; i < totalBars; i++) {\n    // 使用对数分布使低频更加清晰\n    const index = Math.floor(Math.pow(i / totalBars, 2) * maxFreq);\n    const value = frequencies[index] / 255; // 归一化到0-1\n\n    const barHeight = Math.max(minHeight, value * height);\n    const x = i * (barWidth + barSpacing);\n    const y = height - barHeight;\n\n    // 根据频率和音量生成颜色\n    const colorPercent = value;\n    const barColor = getGradientColor(startColor, endColor, colorPercent);\n    ctx.fillStyle = barColor;\n    ctx.fillRect(x, y, barWidth, barHeight);\n  }\n};\n\n// 波形图\nexport const drawWaveform = (ctx, waveform, width, height, options = {}) => {\n  const {\n    lineWidth = 2,\n    color = '#ba68c8',\n    filled = false,\n    mirror = false\n  } = options;\n  ctx.clearRect(0, 0, width, height);\n  ctx.lineWidth = lineWidth;\n  ctx.strokeStyle = color;\n  ctx.fillStyle = color;\n  const centerY = height / 2;\n  const step = Math.ceil(waveform.length / width);\n  ctx.beginPath();\n  if (filled) {\n    ctx.moveTo(0, centerY);\n  }\n  for (let i = 0; i < width; i++) {\n    const index = Math.floor(i * step);\n    const value = waveform[index];\n\n    // 计算y坐标，波形值范围是-1到1\n    const y = mirror ? centerY + value * centerY // 将波形映射到整个高度\n    : centerY + value * (centerY * 0.8); // 留出一些边距\n\n    if (i === 0) {\n      ctx.moveTo(i, y);\n    } else {\n      ctx.lineTo(i, y);\n    }\n  }\n  if (filled) {\n    ctx.lineTo(width, centerY);\n    ctx.fill();\n  } else {\n    ctx.stroke();\n  }\n};\n\n// 圆形频谱\nexport const drawCircularSpectrum = (ctx, frequencies, width, height, options = {}) => {\n  const {\n    radius = Math.min(width, height) / 3,\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    lineWidth = 2,\n    rotation = 0\n  } = options;\n  ctx.clearRect(0, 0, width, height);\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const maxBars = 180; // 圆周上的点数\n  const step = Math.ceil(frequencies.length / maxBars);\n  for (let i = 0; i < maxBars; i++) {\n    const index = Math.floor(i * step);\n    const value = frequencies[index] / 255; // 归一化到0-1\n\n    const barLength = radius * (0.5 + value * 0.5); // 长度在半径的50%-100%之间变化\n    const angle = i / maxBars * Math.PI * 2 + rotation;\n    const x1 = centerX + Math.cos(angle) * radius;\n    const y1 = centerY + Math.sin(angle) * radius;\n    const x2 = centerX + Math.cos(angle) * (radius + barLength);\n    const y2 = centerY + Math.sin(angle) * (radius + barLength);\n    const color = getGradientColor(startColor, endColor, value);\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n  }\n};\n\n// 粒子系统\n\nexport const createParticles = (count, width, height, options = {}) => {\n  const {\n    minSize = 2,\n    maxSize = 8,\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    maxSpeed = 2,\n    baseLife = 100\n  } = options;\n  const particles = [];\n  for (let i = 0; i < count; i++) {\n    const percent = Math.random();\n    const size = minSize + Math.random() * (maxSize - minSize);\n    particles.push({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      size,\n      color: getGradientColor(startColor, endColor, percent),\n      speed: Math.random() * maxSpeed,\n      angle: Math.random() * Math.PI * 2,\n      life: baseLife + Math.random() * baseLife,\n      opacity: 0.7 + Math.random() * 0.3\n    });\n  }\n  return particles;\n};\nexport const updateParticles = (particles, width, height, volume) => {\n  return particles.map(particle => {\n    // 根据音量调整速度\n    const adjustedSpeed = particle.speed * (1 + volume * 3);\n\n    // 更新位置\n    const newX = particle.x + Math.cos(particle.angle) * adjustedSpeed;\n    const newY = particle.y + Math.sin(particle.angle) * adjustedSpeed;\n\n    // 如果粒子离开画布，将其重置到另一边\n    const x = newX < 0 ? width : newX > width ? 0 : newX;\n    const y = newY < 0 ? height : newY > height ? 0 : newY;\n\n    // 递减生命值\n    const life = particle.life - 1;\n\n    // 如果生命值用完，重新创建粒子\n    if (life <= 0) {\n      return {\n        x: Math.random() * width,\n        y: Math.random() * height,\n        size: particle.size,\n        color: particle.color,\n        speed: particle.speed,\n        angle: Math.random() * Math.PI * 2,\n        life: 100 + Math.random() * 100,\n        opacity: 0.7 + Math.random() * 0.3\n      };\n    }\n    return {\n      ...particle,\n      x,\n      y,\n      life\n    };\n  });\n};\nexport const drawParticles = (ctx, particles, volume) => {\n  particles.forEach(particle => {\n    // 根据音量和生命值调整大小和不透明度\n    const sizeMultiplier = 1 + volume * 2;\n    const size = particle.size * sizeMultiplier;\n    const opacity = particle.opacity * particle.life / 200;\n    ctx.globalAlpha = opacity;\n    ctx.fillStyle = particle.color;\n    ctx.beginPath();\n    ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);\n    ctx.fill();\n  });\n  ctx.globalAlpha = 1;\n};\n\n// 存储音频瀑布图的历史数据\nlet waterfallHistory = [];\n\n// 音频瀑布图\nexport const drawAudioWaterfall = (ctx, frequencies, width, height, options = {}) => {\n  const {\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    speed = 2\n  } = options;\n  const frequencyBins = 64; // 采样的频率点数\n  const step = Math.floor(frequencies.length / frequencyBins);\n\n  // 如果历史数据为空，初始化\n  if (waterfallHistory.length === 0) {\n    for (let i = 0; i < Math.floor(height / speed); i++) {\n      const row = Array(frequencyBins).fill(0);\n      waterfallHistory.push(row);\n    }\n  }\n\n  // 获取当前帧的频率数据\n  const currentFrame = [];\n  for (let i = 0; i < frequencyBins; i++) {\n    const index = Math.floor(i * step);\n    currentFrame.push(frequencies[index] / 255); // 归一化到0-1\n  }\n\n  // 更新历史数据\n  waterfallHistory.unshift(currentFrame);\n  if (waterfallHistory.length > Math.floor(height / speed)) {\n    waterfallHistory.pop();\n  }\n\n  // 清除画布\n  ctx.clearRect(0, 0, width, height);\n\n  // 绘制瀑布图\n  const binWidth = width / frequencyBins;\n  waterfallHistory.forEach((row, rowIndex) => {\n    const y = rowIndex * speed;\n    row.forEach((value, binIndex) => {\n      const x = binIndex * binWidth;\n      const color = getGradientColor(startColor, endColor, value);\n      ctx.fillStyle = color;\n      ctx.globalAlpha = 0.8;\n      ctx.fillRect(x, y, binWidth, speed);\n    });\n  });\n  ctx.globalAlpha = 1;\n};\n\n// 万花筒效果\nexport const drawKaleidoscope = (ctx, frequencies, width, height, options = {}) => {\n  const {\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    segments = 8,\n    rotation = 0\n  } = options;\n\n  // 清除画布\n  ctx.clearRect(0, 0, width, height);\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const radius = Math.min(centerX, centerY) * 0.8;\n\n  // 保存当前状态\n  ctx.save();\n  ctx.translate(centerX, centerY);\n  ctx.rotate(rotation);\n\n  // 创建一个基本图形\n  const basePattern = ctx => {\n    const frequencyBins = 32;\n    const step = Math.floor(frequencies.length / frequencyBins);\n    for (let i = 0; i < frequencyBins; i++) {\n      const index = Math.floor(i * step);\n      const value = frequencies[index] / 255; // 归一化到0-1\n\n      const angle = i / frequencyBins * Math.PI * 2 / segments;\n      const length = radius * value;\n      const x = Math.cos(angle) * length;\n      const y = Math.sin(angle) * length;\n      const color = getGradientColor(startColor, endColor, value);\n      ctx.fillStyle = color;\n      ctx.beginPath();\n      ctx.arc(x, y, 5 + value * 15, 0, Math.PI * 2);\n      ctx.fill();\n\n      // 连接到中心的线\n      ctx.strokeStyle = color;\n      ctx.lineWidth = 2;\n      ctx.globalAlpha = 0.5;\n      ctx.beginPath();\n      ctx.moveTo(0, 0);\n      ctx.lineTo(x, y);\n      ctx.stroke();\n      ctx.globalAlpha = 1;\n    }\n  };\n\n  // 绘制多个反射的图形\n  for (let s = 0; s < segments; s++) {\n    ctx.save();\n    ctx.rotate(s / segments * Math.PI * 2);\n    basePattern(ctx);\n    ctx.restore();\n  }\n\n  // 恢复状态\n  ctx.restore();\n};\n\n// 有机形态\nexport const drawOrganicForm = (ctx, frequencies, waveform, width, height, options = {}) => {\n  const {\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    complexity = 0.7\n  } = options;\n\n  // 清除画布\n  ctx.clearRect(0, 0, width, height);\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const baseRadius = Math.min(centerX, centerY) * 0.6;\n  const frequencyBins = 32;\n  const step = Math.floor(frequencies.length / frequencyBins);\n\n  // 计算平均振幅\n  let avgAmplitude = 0;\n  for (let i = 0; i < frequencies.length; i++) {\n    avgAmplitude += frequencies[i] / 255;\n  }\n  avgAmplitude /= frequencies.length;\n\n  // 绘制有机形态\n  ctx.beginPath();\n  for (let i = 0; i <= frequencyBins; i++) {\n    const angle = i / frequencyBins * Math.PI * 2;\n\n    // 使用频率数据和波形数据创建有机的变形效果\n    const freqIndex = Math.floor(i * step) % frequencies.length;\n    const waveIndex = Math.floor(i * waveform.length / frequencyBins) % waveform.length;\n    const frequency = frequencies[freqIndex] / 255;\n    const wave = (waveform[waveIndex] + 1) / 2; // 转换到0-1范围\n\n    // 结合频率和波形数据\n    const variation = frequency * wave * complexity;\n    const radius = baseRadius * (0.7 + variation * 0.5);\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    if (i === 0) {\n      ctx.moveTo(x, y);\n    } else {\n      ctx.lineTo(x, y);\n    }\n  }\n  ctx.closePath();\n\n  // 创建渐变填充\n  const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, baseRadius);\n  gradient.addColorStop(0, startColor);\n  gradient.addColorStop(1, endColor);\n\n  // 填充和描边\n  ctx.fillStyle = gradient;\n  ctx.fill();\n  ctx.strokeStyle = getGradientColor(startColor, endColor, avgAmplitude);\n  ctx.lineWidth = 2;\n  ctx.stroke();\n};\n\n// 俄罗斯方块效果\n\n// 俄罗斯方块块类型形状\nconst TETRIS_SHAPES = [\n// I形\n[[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]],\n// J形\n[[1, 0, 0], [1, 1, 1], [0, 0, 0]],\n// L形\n[[0, 0, 1], [1, 1, 1], [0, 0, 0]],\n// O形\n[[1, 1], [1, 1]],\n// S形\n[[0, 1, 1], [1, 1, 0], [0, 0, 0]],\n// T形\n[[0, 1, 0], [1, 1, 1], [0, 0, 0]],\n// Z形\n[[1, 1, 0], [0, 1, 1], [0, 0, 0]]];\n\n// 存储当前的方块和网格\nlet tetrisGrid = [];\nlet activeBlocks = [];\nlet tetrisLastUpdate = 0;\n\n// 初始化俄罗斯方块网格\nconst initTetrisGrid = (cols, rows) => {\n  tetrisGrid = [];\n  for (let i = 0; i < rows; i++) {\n    tetrisGrid.push(Array(cols).fill(0));\n  }\n};\n\n// 创建新的方块\nconst createTetrisBlock = (cols, startColor, endColor) => {\n  const type = Math.floor(Math.random() * TETRIS_SHAPES.length);\n  const color = getGradientColor(startColor, endColor, Math.random());\n  return {\n    x: Math.floor(cols / 2) - Math.floor(TETRIS_SHAPES[type][0].length / 2),\n    y: 0,\n    type,\n    rotation: 0,\n    color\n  };\n};\n\n// 绘制俄罗斯方块效果\nexport const drawTetris = (ctx, frequencies, width, height, options = {}) => {\n  const {\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    speed = 1\n  } = options;\n\n  // 计算网格尺寸\n  const cols = 12;\n  const rows = 20;\n  const cellSize = Math.min(width / cols, height / rows);\n  const gridWidth = cols * cellSize;\n  const gridHeight = rows * cellSize;\n  const offsetX = (width - gridWidth) / 2;\n  const offsetY = (height - gridHeight) / 2;\n\n  // 初始化网格\n  if (tetrisGrid.length === 0) {\n    initTetrisGrid(cols, rows);\n  }\n\n  // 根据音频数据控制游戏速度\n  const now = Date.now();\n  const avgFreq = Array.from(frequencies).reduce((sum, val) => sum + val, 0) / frequencies.length;\n  const normalizedFreq = avgFreq / 255;\n\n  // 音量越大，方块下落越快\n  const updateInterval = 1000 - normalizedFreq * 800;\n\n  // 音量脉冲添加新方块\n  if (normalizedFreq > 0.6 && Math.random() < 0.1) {\n    activeBlocks.push(createTetrisBlock(cols, startColor, endColor));\n  }\n\n  // 更新方块位置\n  if (now - tetrisLastUpdate > updateInterval) {\n    tetrisLastUpdate = now;\n\n    // 创建初始方块\n    if (activeBlocks.length === 0) {\n      activeBlocks.push(createTetrisBlock(cols, startColor, endColor));\n    }\n\n    // 尝试移动活动方块\n    activeBlocks.forEach(block => {\n      block.y += 1;\n\n      // 如果方块触底或碰到其他方块，固定它并创建新方块\n      const shape = TETRIS_SHAPES[block.type];\n      let hitBottom = false;\n\n      // 检查是否触底\n      for (let y = 0; y < shape.length; y++) {\n        for (let x = 0; x < shape[y].length; x++) {\n          if (shape[y][x] === 0) continue;\n          const gridY = block.y + y;\n          const gridX = block.x + x;\n\n          // 检查是否到达底部或碰到其他方块\n          if (gridY >= rows || gridY >= 0 && tetrisGrid[gridY][gridX] !== 0) {\n            hitBottom = true;\n            break;\n          }\n        }\n        if (hitBottom) break;\n      }\n\n      // 如果触底，将方块固定到网格\n      if (hitBottom) {\n        // 回退一步\n        block.y -= 1;\n\n        // 将方块添加到网格\n        for (let y = 0; y < shape.length; y++) {\n          for (let x = 0; x < shape[y].length; x++) {\n            if (shape[y][x] === 0) continue;\n            const gridY = block.y + y;\n            const gridX = block.x + x;\n            if (gridY >= 0 && gridY < rows && gridX >= 0 && gridX < cols) {\n              tetrisGrid[gridY][gridX] = 1;\n            }\n          }\n        }\n      }\n    });\n\n    // 删除已固定的方块\n    activeBlocks = activeBlocks.filter(block => {\n      const shape = TETRIS_SHAPES[block.type];\n      for (let y = 0; y < shape.length; y++) {\n        for (let x = 0; x < shape[y].length; x++) {\n          if (shape[y][x] === 0) continue;\n          const gridY = block.y + y;\n          const gridX = block.x + x;\n\n          // 如果方块已经添加到网格中，则删除它\n          if (gridY >= 0 && gridY < rows && gridX >= 0 && gridX < cols && tetrisGrid[gridY][gridX] === 1) {\n            return false;\n          }\n        }\n      }\n      return true;\n    });\n\n    // 清除完整的行\n    for (let y = rows - 1; y >= 0; y--) {\n      if (tetrisGrid[y].every(cell => cell === 1)) {\n        // 移除该行\n        tetrisGrid.splice(y, 1);\n        // 在顶部添加新行\n        tetrisGrid.unshift(Array(cols).fill(0));\n      }\n    }\n\n    // 根据音量随机添加新方块\n    if (Math.random() < 0.1 * normalizedFreq) {\n      activeBlocks.push(createTetrisBlock(cols, startColor, endColor));\n    }\n  }\n\n  // 清除画布\n  ctx.clearRect(0, 0, width, height);\n\n  // 绘制网格背景\n  ctx.fillStyle = '#111';\n  ctx.fillRect(offsetX, offsetY, gridWidth, gridHeight);\n\n  // 绘制边框\n  ctx.strokeStyle = '#333';\n  ctx.lineWidth = 2;\n  ctx.strokeRect(offsetX, offsetY, gridWidth, gridHeight);\n\n  // 绘制固定方块\n  for (let y = 0; y < rows; y++) {\n    for (let x = 0; x < cols; x++) {\n      if (tetrisGrid[y][x] === 1) {\n        const cellX = offsetX + x * cellSize;\n        const cellY = offsetY + y * cellSize;\n\n        // 根据频率选择颜色\n        const freqIndex = (x + y) % frequencies.length;\n        const colorPercent = frequencies[freqIndex] / 255;\n        const color = getGradientColor(startColor, endColor, colorPercent);\n        ctx.fillStyle = color;\n        ctx.fillRect(cellX, cellY, cellSize - 1, cellSize - 1);\n      }\n    }\n  }\n\n  // 绘制活动方块\n  activeBlocks.forEach(block => {\n    const shape = TETRIS_SHAPES[block.type];\n    for (let y = 0; y < shape.length; y++) {\n      for (let x = 0; x < shape[y].length; x++) {\n        if (shape[y][x] === 0) continue;\n        const cellX = offsetX + (block.x + x) * cellSize;\n        const cellY = offsetY + (block.y + y) * cellSize;\n        if (cellX >= offsetX && cellX < offsetX + gridWidth && cellY >= offsetY && cellY < offsetY + gridHeight) {\n          ctx.fillStyle = block.color;\n          ctx.fillRect(cellX, cellY, cellSize - 1, cellSize - 1);\n        }\n      }\n    }\n  });\n};\n\n// 卡通嘴型同步\n// 存储嘴型状态\nlet mouthRadius = 0;\nlet eyeState = 0;\nlet blinkCounter = 0;\n\n// 绘制卡通人物嘴型同步效果\nexport const drawLipSync = (ctx, frequencies, waveform, width, height, options = {}) => {\n  const {\n    faceColor = '#ffcc99',\n    lipColor = '#ff6666'\n  } = options;\n\n  // 清除画布\n  ctx.clearRect(0, 0, width, height);\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const faceSize = Math.min(width, height) * 0.6;\n\n  // 计算平均音量和低频强度\n  let avgVolume = 0;\n  let bassIntensity = 0;\n\n  // 获取低频能量（嘴巴张开程度）\n  for (let i = 0; i < 10; i++) {\n    bassIntensity += frequencies[i] / 255;\n  }\n  bassIntensity /= 10;\n\n  // 获取总体音量（表情活跃度）\n  for (let i = 0; i < frequencies.length; i++) {\n    avgVolume += frequencies[i] / 255;\n  }\n  avgVolume /= frequencies.length;\n\n  // 平滑嘴型变化\n  mouthRadius = mouthRadius * 0.7 + bassIntensity * 0.3 * faceSize * 0.3;\n\n  // 眨眼控制\n  blinkCounter++;\n  if (blinkCounter > 120 || avgVolume > 0.7 && Math.random() > 0.7) {\n    eyeState = (eyeState + 1) % 3;\n    if (eyeState === 0) {\n      blinkCounter = 0;\n    }\n  }\n\n  // 绘制脸部\n  ctx.fillStyle = faceColor;\n  ctx.beginPath();\n  ctx.arc(centerX, centerY, faceSize / 2, 0, Math.PI * 2);\n  ctx.fill();\n\n  // 绘制嘴巴\n  ctx.fillStyle = lipColor;\n  ctx.beginPath();\n  ctx.ellipse(centerX, centerY + faceSize * 0.15, mouthRadius * 1.5, mouthRadius, 0, 0, Math.PI * 2);\n  ctx.fill();\n\n  // 绘制嘴内（黑色）\n  ctx.fillStyle = '#000';\n  ctx.beginPath();\n  ctx.ellipse(centerX, centerY + faceSize * 0.15, mouthRadius * 1.2, mouthRadius * 0.7, 0, 0, Math.PI * 2);\n  ctx.fill();\n\n  // 根据波形绘制舌头\n  let tongueHeight = 0;\n  for (let i = 0; i < waveform.length; i += 10) {\n    tongueHeight += Math.abs(waveform[i]);\n  }\n  tongueHeight = tongueHeight / (waveform.length / 10) * mouthRadius * 0.8;\n  if (tongueHeight > 0.01) {\n    ctx.fillStyle = '#ff9999';\n    ctx.beginPath();\n    ctx.ellipse(centerX, centerY + faceSize * 0.15 + mouthRadius * 0.2, mouthRadius * 0.8, tongueHeight, 0, 0, Math.PI);\n    ctx.fill();\n  }\n\n  // 绘制眼睛\n  const eyeX1 = centerX - faceSize * 0.15;\n  const eyeX2 = centerX + faceSize * 0.15;\n  const eyeY = centerY - faceSize * 0.1;\n  const eyeSize = faceSize * 0.1;\n\n  // 眼白\n  ctx.fillStyle = '#ffffff';\n  ctx.beginPath();\n  ctx.arc(eyeX1, eyeY, eyeSize, 0, Math.PI * 2);\n  ctx.fill();\n  ctx.beginPath();\n  ctx.arc(eyeX2, eyeY, eyeSize, 0, Math.PI * 2);\n  ctx.fill();\n\n  // 眼珠（根据音频移动）\n  const eyeMoveX = (frequencies[15] / 255 - 0.5) * eyeSize * 0.5;\n  const eyeMoveY = (frequencies[20] / 255 - 0.5) * eyeSize * 0.5;\n  if (eyeState === 0) {\n    // 正常眼睛\n    ctx.fillStyle = '#000000';\n    ctx.beginPath();\n    ctx.arc(eyeX1 + eyeMoveX, eyeY + eyeMoveY, eyeSize * 0.4, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(eyeX2 + eyeMoveX, eyeY + eyeMoveY, eyeSize * 0.4, 0, Math.PI * 2);\n    ctx.fill();\n\n    // 眼神反光\n    ctx.fillStyle = '#ffffff';\n    ctx.beginPath();\n    ctx.arc(eyeX1 + eyeMoveX + eyeSize * 0.1, eyeY + eyeMoveY - eyeSize * 0.1, eyeSize * 0.1, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(eyeX2 + eyeMoveX + eyeSize * 0.1, eyeY + eyeMoveY - eyeSize * 0.1, eyeSize * 0.1, 0, Math.PI * 2);\n    ctx.fill();\n  } else if (eyeState === 1) {\n    // 半闭眼\n    ctx.fillStyle = '#000000';\n    ctx.beginPath();\n    ctx.ellipse(eyeX1, eyeY, eyeSize * 0.4, eyeSize * 0.1, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.ellipse(eyeX2, eyeY, eyeSize * 0.4, eyeSize * 0.1, 0, 0, Math.PI * 2);\n    ctx.fill();\n  } else {\n    // 闭眼\n    ctx.strokeStyle = '#000000';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(eyeX1 - eyeSize * 0.5, eyeY);\n    ctx.lineTo(eyeX1 + eyeSize * 0.5, eyeY);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.moveTo(eyeX2 - eyeSize * 0.5, eyeY);\n    ctx.lineTo(eyeX2 + eyeSize * 0.5, eyeY);\n    ctx.stroke();\n  }\n\n  // 绘制眉毛（随着高频变化）\n  const browRaise = Math.max(0, frequencies[30] / 255 - 0.5) * faceSize * 0.1;\n  ctx.strokeStyle = '#000000';\n  ctx.lineWidth = 3;\n\n  // 左眉毛\n  ctx.beginPath();\n  ctx.moveTo(eyeX1 - eyeSize * 1.2, eyeY - eyeSize * 1.2 - browRaise);\n  ctx.lineTo(eyeX1 + eyeSize * 0.8, eyeY - eyeSize - browRaise * 0.5);\n  ctx.stroke();\n\n  // 右眉毛\n  ctx.beginPath();\n  ctx.moveTo(eyeX2 + eyeSize * 1.2, eyeY - eyeSize * 1.2 - browRaise);\n  ctx.lineTo(eyeX2 - eyeSize * 0.8, eyeY - eyeSize - browRaise * 0.5);\n  ctx.stroke();\n\n  // 根据音量添加表情变化（脸红）\n  if (avgVolume > 0.6) {\n    ctx.fillStyle = 'rgba(255, 150, 150, 0.3)';\n    ctx.beginPath();\n    ctx.arc(centerX - faceSize * 0.25, centerY + faceSize * 0.05, faceSize * 0.12, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(centerX + faceSize * 0.25, centerY + faceSize * 0.05, faceSize * 0.12, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  // 绘制音符（在强拍时）\n  if (avgVolume > 0.65 && Math.random() > 0.7) {\n    const noteSize = faceSize * 0.15;\n    const noteX = centerX + faceSize * 0.6 * (Math.random() * 2 - 1);\n    const noteY = centerY - faceSize * 0.7;\n    ctx.fillStyle = '#9c27b0';\n    ctx.beginPath();\n    ctx.ellipse(noteX, noteY, noteSize * 0.6, noteSize * 0.4, Math.PI * 0.25, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = '#9c27b0';\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.moveTo(noteX + noteSize * 0.5, noteY);\n    ctx.lineTo(noteX + noteSize * 0.5, noteY - noteSize * 1.2);\n    ctx.stroke();\n  }\n};","map":{"version":3,"names":["getGradientColor","startColor","endColor","percent","start","r","parseInt","slice","g","b","end","Math","floor","toString","padStart","drawSpectrumBars","ctx","frequencies","width","height","options","barWidth","barSpacing","minHeight","maxFreq","length","clearRect","totalBars","min","frequencyStep","i","index","pow","value","barHeight","max","x","y","colorPercent","barColor","fillStyle","fillRect","drawWaveform","waveform","lineWidth","color","filled","mirror","strokeStyle","centerY","step","ceil","beginPath","moveTo","lineTo","fill","stroke","drawCircularSpectrum","radius","rotation","centerX","maxBars","barLength","angle","PI","x1","cos","y1","sin","x2","y2","createParticles","count","minSize","maxSize","maxSpeed","baseLife","particles","random","size","push","speed","life","opacity","updateParticles","volume","map","particle","adjustedSpeed","newX","newY","drawParticles","forEach","sizeMultiplier","globalAlpha","arc","waterfallHistory","drawAudioWaterfall","frequencyBins","row","Array","currentFrame","unshift","pop","binWidth","rowIndex","binIndex","drawKaleidoscope","segments","save","translate","rotate","basePattern","s","restore","drawOrganicForm","complexity","baseRadius","avgAmplitude","freqIndex","waveIndex","frequency","wave","variation","closePath","gradient","createRadialGradient","addColorStop","TETRIS_SHAPES","tetrisGrid","activeBlocks","tetrisLastUpdate","initTetrisGrid","cols","rows","createTetrisBlock","type","drawTetris","cellSize","gridWidth","gridHeight","offsetX","offsetY","now","Date","avgFreq","from","reduce","sum","val","normalizedFreq","updateInterval","block","shape","hitBottom","gridY","gridX","filter","every","cell","splice","strokeRect","cellX","cellY","mouthRadius","eyeState","blinkCounter","drawLipSync","faceColor","lipColor","faceSize","avgVolume","bassIntensity","ellipse","tongueHeight","abs","eyeX1","eyeX2","eyeY","eyeSize","eyeMoveX","eyeMoveY","browRaise","noteSize","noteX","noteY"],"sources":["C:/Users/20213/Desktop/web/src/utils/visualEffects.ts"],"sourcesContent":["// 定义常用的可视化效果\n\n// 颜色工具\nexport const getGradientColor = (\n  startColor: string,\n  endColor: string, \n  percent: number\n): string => {\n  // 解析颜色\n  const start = {\n    r: parseInt(startColor.slice(1, 3), 16),\n    g: parseInt(startColor.slice(3, 5), 16),\n    b: parseInt(startColor.slice(5, 7), 16)\n  };\n  \n  const end = {\n    r: parseInt(endColor.slice(1, 3), 16),\n    g: parseInt(endColor.slice(3, 5), 16),\n    b: parseInt(endColor.slice(5, 7), 16)\n  };\n  \n  // 计算渐变颜色\n  const r = Math.floor(start.r + percent * (end.r - start.r));\n  const g = Math.floor(start.g + percent * (end.g - start.g));\n  const b = Math.floor(start.b + percent * (end.b - start.b));\n  \n  // 转换为十六进制\n  return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n};\n\n// 频谱柱状图\nexport const drawSpectrumBars = (\n  ctx: CanvasRenderingContext2D,\n  frequencies: Uint8Array,\n  width: number,\n  height: number,\n  options: {\n    barWidth?: number;\n    barSpacing?: number;\n    startColor?: string;\n    endColor?: string;\n    minHeight?: number;\n    maxFreq?: number;\n  } = {}\n) => {\n  const {\n    barWidth = 5,\n    barSpacing = 2,\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    minHeight = 5,\n    maxFreq = frequencies.length * 0.75 // 只显示频率范围的75%，高频部分通常人耳听不到\n  } = options;\n  \n  ctx.clearRect(0, 0, width, height);\n  \n  const totalBars = Math.min(Math.floor(width / (barWidth + barSpacing)), maxFreq);\n  const frequencyStep = Math.floor(frequencies.length / totalBars);\n  \n  for (let i = 0; i < totalBars; i++) {\n    // 使用对数分布使低频更加清晰\n    const index = Math.floor(Math.pow(i / totalBars, 2) * maxFreq);\n    const value = frequencies[index] / 255; // 归一化到0-1\n    \n    const barHeight = Math.max(minHeight, value * height);\n    const x = i * (barWidth + barSpacing);\n    const y = height - barHeight;\n    \n    // 根据频率和音量生成颜色\n    const colorPercent = value;\n    const barColor = getGradientColor(startColor, endColor, colorPercent);\n    \n    ctx.fillStyle = barColor;\n    ctx.fillRect(x, y, barWidth, barHeight);\n  }\n};\n\n// 波形图\nexport const drawWaveform = (\n  ctx: CanvasRenderingContext2D,\n  waveform: Float32Array,\n  width: number,\n  height: number,\n  options: {\n    lineWidth?: number;\n    color?: string;\n    filled?: boolean;\n    mirror?: boolean;\n  } = {}\n) => {\n  const {\n    lineWidth = 2,\n    color = '#ba68c8',\n    filled = false,\n    mirror = false\n  } = options;\n  \n  ctx.clearRect(0, 0, width, height);\n  ctx.lineWidth = lineWidth;\n  ctx.strokeStyle = color;\n  ctx.fillStyle = color;\n  \n  const centerY = height / 2;\n  const step = Math.ceil(waveform.length / width);\n  \n  ctx.beginPath();\n  \n  if (filled) {\n    ctx.moveTo(0, centerY);\n  }\n  \n  for (let i = 0; i < width; i++) {\n    const index = Math.floor(i * step);\n    const value = waveform[index];\n    \n    // 计算y坐标，波形值范围是-1到1\n    const y = mirror\n      ? centerY + value * centerY // 将波形映射到整个高度\n      : centerY + value * (centerY * 0.8); // 留出一些边距\n      \n    if (i === 0) {\n      ctx.moveTo(i, y);\n    } else {\n      ctx.lineTo(i, y);\n    }\n  }\n  \n  if (filled) {\n    ctx.lineTo(width, centerY);\n    ctx.fill();\n  } else {\n    ctx.stroke();\n  }\n};\n\n// 圆形频谱\nexport const drawCircularSpectrum = (\n  ctx: CanvasRenderingContext2D,\n  frequencies: Uint8Array,\n  width: number,\n  height: number,\n  options: {\n    radius?: number;\n    startColor?: string;\n    endColor?: string;\n    lineWidth?: number;\n    rotation?: number;\n  } = {}\n) => {\n  const {\n    radius = Math.min(width, height) / 3,\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    lineWidth = 2,\n    rotation = 0\n  } = options;\n  \n  ctx.clearRect(0, 0, width, height);\n  \n  const centerX = width / 2;\n  const centerY = height / 2;\n  const maxBars = 180; // 圆周上的点数\n  const step = Math.ceil(frequencies.length / maxBars);\n  \n  for (let i = 0; i < maxBars; i++) {\n    const index = Math.floor(i * step);\n    const value = frequencies[index] / 255; // 归一化到0-1\n    \n    const barLength = radius * (0.5 + value * 0.5); // 长度在半径的50%-100%之间变化\n    const angle = (i / maxBars) * Math.PI * 2 + rotation;\n    \n    const x1 = centerX + Math.cos(angle) * radius;\n    const y1 = centerY + Math.sin(angle) * radius;\n    \n    const x2 = centerX + Math.cos(angle) * (radius + barLength);\n    const y2 = centerY + Math.sin(angle) * (radius + barLength);\n    \n    const color = getGradientColor(startColor, endColor, value);\n    \n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = color;\n    \n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n  }\n};\n\n// 粒子系统\nexport interface Particle {\n  x: number;\n  y: number;\n  size: number;\n  color: string;\n  speed: number;\n  angle: number;\n  life: number;\n  opacity: number;\n}\n\nexport const createParticles = (\n  count: number,\n  width: number,\n  height: number,\n  options: {\n    minSize?: number;\n    maxSize?: number;\n    startColor?: string;\n    endColor?: string;\n    maxSpeed?: number;\n    baseLife?: number;\n  } = {}\n): Particle[] => {\n  const {\n    minSize = 2,\n    maxSize = 8,\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    maxSpeed = 2,\n    baseLife = 100\n  } = options;\n  \n  const particles: Particle[] = [];\n  \n  for (let i = 0; i < count; i++) {\n    const percent = Math.random();\n    const size = minSize + Math.random() * (maxSize - minSize);\n    \n    particles.push({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      size,\n      color: getGradientColor(startColor, endColor, percent),\n      speed: Math.random() * maxSpeed,\n      angle: Math.random() * Math.PI * 2,\n      life: baseLife + Math.random() * baseLife,\n      opacity: 0.7 + Math.random() * 0.3\n    });\n  }\n  \n  return particles;\n};\n\nexport const updateParticles = (\n  particles: Particle[],\n  width: number,\n  height: number,\n  volume: number\n): Particle[] => {\n  return particles.map(particle => {\n    // 根据音量调整速度\n    const adjustedSpeed = particle.speed * (1 + volume * 3);\n    \n    // 更新位置\n    const newX = particle.x + Math.cos(particle.angle) * adjustedSpeed;\n    const newY = particle.y + Math.sin(particle.angle) * adjustedSpeed;\n    \n    // 如果粒子离开画布，将其重置到另一边\n    const x = newX < 0 ? width : newX > width ? 0 : newX;\n    const y = newY < 0 ? height : newY > height ? 0 : newY;\n    \n    // 递减生命值\n    const life = particle.life - 1;\n    \n    // 如果生命值用完，重新创建粒子\n    if (life <= 0) {\n      return {\n        x: Math.random() * width,\n        y: Math.random() * height,\n        size: particle.size,\n        color: particle.color,\n        speed: particle.speed,\n        angle: Math.random() * Math.PI * 2,\n        life: 100 + Math.random() * 100,\n        opacity: 0.7 + Math.random() * 0.3\n      };\n    }\n    \n    return {\n      ...particle,\n      x,\n      y,\n      life\n    };\n  });\n};\n\nexport const drawParticles = (\n  ctx: CanvasRenderingContext2D,\n  particles: Particle[],\n  volume: number\n) => {\n  particles.forEach(particle => {\n    // 根据音量和生命值调整大小和不透明度\n    const sizeMultiplier = 1 + volume * 2;\n    const size = particle.size * sizeMultiplier;\n    const opacity = (particle.opacity * particle.life) / 200;\n    \n    ctx.globalAlpha = opacity;\n    ctx.fillStyle = particle.color;\n    \n    ctx.beginPath();\n    ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);\n    ctx.fill();\n  });\n  \n  ctx.globalAlpha = 1;\n};\n\n// 存储音频瀑布图的历史数据\nlet waterfallHistory: number[][] = [];\n\n// 音频瀑布图\nexport const drawAudioWaterfall = (\n  ctx: CanvasRenderingContext2D,\n  frequencies: Uint8Array,\n  width: number,\n  height: number,\n  options: {\n    startColor?: string;\n    endColor?: string;\n    speed?: number;\n  } = {}\n) => {\n  const {\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    speed = 2\n  } = options;\n  \n  const frequencyBins = 64; // 采样的频率点数\n  const step = Math.floor(frequencies.length / frequencyBins);\n  \n  // 如果历史数据为空，初始化\n  if (waterfallHistory.length === 0) {\n    for (let i = 0; i < Math.floor(height / speed); i++) {\n      const row = Array(frequencyBins).fill(0);\n      waterfallHistory.push(row);\n    }\n  }\n  \n  // 获取当前帧的频率数据\n  const currentFrame = [];\n  for (let i = 0; i < frequencyBins; i++) {\n    const index = Math.floor(i * step);\n    currentFrame.push(frequencies[index] / 255); // 归一化到0-1\n  }\n  \n  // 更新历史数据\n  waterfallHistory.unshift(currentFrame);\n  if (waterfallHistory.length > Math.floor(height / speed)) {\n    waterfallHistory.pop();\n  }\n  \n  // 清除画布\n  ctx.clearRect(0, 0, width, height);\n  \n  // 绘制瀑布图\n  const binWidth = width / frequencyBins;\n  \n  waterfallHistory.forEach((row, rowIndex) => {\n    const y = rowIndex * speed;\n    \n    row.forEach((value, binIndex) => {\n      const x = binIndex * binWidth;\n      const color = getGradientColor(startColor, endColor, value);\n      \n      ctx.fillStyle = color;\n      ctx.globalAlpha = 0.8;\n      ctx.fillRect(x, y, binWidth, speed);\n    });\n  });\n  \n  ctx.globalAlpha = 1;\n};\n\n// 万花筒效果\nexport const drawKaleidoscope = (\n  ctx: CanvasRenderingContext2D,\n  frequencies: Uint8Array,\n  width: number,\n  height: number,\n  options: {\n    startColor?: string;\n    endColor?: string;\n    segments?: number;\n    rotation?: number;\n  } = {}\n) => {\n  const {\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    segments = 8,\n    rotation = 0\n  } = options;\n  \n  // 清除画布\n  ctx.clearRect(0, 0, width, height);\n  \n  const centerX = width / 2;\n  const centerY = height / 2;\n  const radius = Math.min(centerX, centerY) * 0.8;\n  \n  // 保存当前状态\n  ctx.save();\n  ctx.translate(centerX, centerY);\n  ctx.rotate(rotation);\n  \n  // 创建一个基本图形\n  const basePattern = (ctx: CanvasRenderingContext2D) => {\n    const frequencyBins = 32;\n    const step = Math.floor(frequencies.length / frequencyBins);\n    \n    for (let i = 0; i < frequencyBins; i++) {\n      const index = Math.floor(i * step);\n      const value = frequencies[index] / 255; // 归一化到0-1\n      \n      const angle = (i / frequencyBins) * Math.PI * 2 / segments;\n      const length = radius * value;\n      \n      const x = Math.cos(angle) * length;\n      const y = Math.sin(angle) * length;\n      \n      const color = getGradientColor(startColor, endColor, value);\n      \n      ctx.fillStyle = color;\n      ctx.beginPath();\n      ctx.arc(x, y, 5 + value * 15, 0, Math.PI * 2);\n      ctx.fill();\n      \n      // 连接到中心的线\n      ctx.strokeStyle = color;\n      ctx.lineWidth = 2;\n      ctx.globalAlpha = 0.5;\n      ctx.beginPath();\n      ctx.moveTo(0, 0);\n      ctx.lineTo(x, y);\n      ctx.stroke();\n      ctx.globalAlpha = 1;\n    }\n  };\n  \n  // 绘制多个反射的图形\n  for (let s = 0; s < segments; s++) {\n    ctx.save();\n    ctx.rotate((s / segments) * Math.PI * 2);\n    basePattern(ctx);\n    ctx.restore();\n  }\n  \n  // 恢复状态\n  ctx.restore();\n};\n\n// 有机形态\nexport const drawOrganicForm = (\n  ctx: CanvasRenderingContext2D,\n  frequencies: Uint8Array,\n  waveform: Float32Array,\n  width: number,\n  height: number,\n  options: {\n    startColor?: string;\n    endColor?: string;\n    complexity?: number;\n  } = {}\n) => {\n  const {\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    complexity = 0.7\n  } = options;\n  \n  // 清除画布\n  ctx.clearRect(0, 0, width, height);\n  \n  const centerX = width / 2;\n  const centerY = height / 2;\n  const baseRadius = Math.min(centerX, centerY) * 0.6;\n  \n  const frequencyBins = 32;\n  const step = Math.floor(frequencies.length / frequencyBins);\n  \n  // 计算平均振幅\n  let avgAmplitude = 0;\n  for (let i = 0; i < frequencies.length; i++) {\n    avgAmplitude += frequencies[i] / 255;\n  }\n  avgAmplitude /= frequencies.length;\n  \n  // 绘制有机形态\n  ctx.beginPath();\n  \n  for (let i = 0; i <= frequencyBins; i++) {\n    const angle = (i / frequencyBins) * Math.PI * 2;\n    \n    // 使用频率数据和波形数据创建有机的变形效果\n    const freqIndex = Math.floor(i * step) % frequencies.length;\n    const waveIndex = Math.floor(i * waveform.length / frequencyBins) % waveform.length;\n    \n    const frequency = frequencies[freqIndex] / 255;\n    const wave = (waveform[waveIndex] + 1) / 2; // 转换到0-1范围\n    \n    // 结合频率和波形数据\n    const variation = frequency * wave * complexity;\n    const radius = baseRadius * (0.7 + variation * 0.5);\n    \n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      ctx.moveTo(x, y);\n    } else {\n      ctx.lineTo(x, y);\n    }\n  }\n  \n  ctx.closePath();\n  \n  // 创建渐变填充\n  const gradient = ctx.createRadialGradient(\n    centerX, centerY, 0,\n    centerX, centerY, baseRadius\n  );\n  gradient.addColorStop(0, startColor);\n  gradient.addColorStop(1, endColor);\n  \n  // 填充和描边\n  ctx.fillStyle = gradient;\n  ctx.fill();\n  \n  ctx.strokeStyle = getGradientColor(startColor, endColor, avgAmplitude);\n  ctx.lineWidth = 2;\n  ctx.stroke();\n};\n\n// 俄罗斯方块效果\ninterface TetrisBlock {\n  x: number;\n  y: number;\n  type: number;\n  rotation: number;\n  color: string;\n}\n\n// 俄罗斯方块块类型形状\nconst TETRIS_SHAPES = [\n  // I形\n  [\n    [0, 0, 0, 0],\n    [1, 1, 1, 1],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0]\n  ],\n  // J形\n  [\n    [1, 0, 0],\n    [1, 1, 1],\n    [0, 0, 0]\n  ],\n  // L形\n  [\n    [0, 0, 1],\n    [1, 1, 1],\n    [0, 0, 0]\n  ],\n  // O形\n  [\n    [1, 1],\n    [1, 1]\n  ],\n  // S形\n  [\n    [0, 1, 1],\n    [1, 1, 0],\n    [0, 0, 0]\n  ],\n  // T形\n  [\n    [0, 1, 0],\n    [1, 1, 1],\n    [0, 0, 0]\n  ],\n  // Z形\n  [\n    [1, 1, 0],\n    [0, 1, 1],\n    [0, 0, 0]\n  ]\n];\n\n// 存储当前的方块和网格\nlet tetrisGrid: number[][] = [];\nlet activeBlocks: TetrisBlock[] = [];\nlet tetrisLastUpdate = 0;\n\n// 初始化俄罗斯方块网格\nconst initTetrisGrid = (cols: number, rows: number) => {\n  tetrisGrid = [];\n  for (let i = 0; i < rows; i++) {\n    tetrisGrid.push(Array(cols).fill(0));\n  }\n};\n\n// 创建新的方块\nconst createTetrisBlock = (cols: number, startColor: string, endColor: string): TetrisBlock => {\n  const type = Math.floor(Math.random() * TETRIS_SHAPES.length);\n  const color = getGradientColor(startColor, endColor, Math.random());\n  \n  return {\n    x: Math.floor(cols / 2) - Math.floor(TETRIS_SHAPES[type][0].length / 2),\n    y: 0,\n    type,\n    rotation: 0,\n    color\n  };\n};\n\n// 绘制俄罗斯方块效果\nexport const drawTetris = (\n  ctx: CanvasRenderingContext2D,\n  frequencies: Uint8Array,\n  width: number,\n  height: number,\n  options: {\n    startColor?: string;\n    endColor?: string;\n    speed?: number;\n  } = {}\n) => {\n  const {\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    speed = 1\n  } = options;\n  \n  // 计算网格尺寸\n  const cols = 12;\n  const rows = 20;\n  const cellSize = Math.min(width / cols, height / rows);\n  const gridWidth = cols * cellSize;\n  const gridHeight = rows * cellSize;\n  const offsetX = (width - gridWidth) / 2;\n  const offsetY = (height - gridHeight) / 2;\n  \n  // 初始化网格\n  if (tetrisGrid.length === 0) {\n    initTetrisGrid(cols, rows);\n  }\n  \n  // 根据音频数据控制游戏速度\n  const now = Date.now();\n  const avgFreq = Array.from(frequencies).reduce((sum, val) => sum + val, 0) / frequencies.length;\n  const normalizedFreq = avgFreq / 255;\n  \n  // 音量越大，方块下落越快\n  const updateInterval = 1000 - normalizedFreq * 800;\n  \n  // 音量脉冲添加新方块\n  if (normalizedFreq > 0.6 && Math.random() < 0.1) {\n    activeBlocks.push(createTetrisBlock(cols, startColor, endColor));\n  }\n  \n  // 更新方块位置\n  if (now - tetrisLastUpdate > updateInterval) {\n    tetrisLastUpdate = now;\n    \n    // 创建初始方块\n    if (activeBlocks.length === 0) {\n      activeBlocks.push(createTetrisBlock(cols, startColor, endColor));\n    }\n    \n    // 尝试移动活动方块\n    activeBlocks.forEach(block => {\n      block.y += 1;\n      \n      // 如果方块触底或碰到其他方块，固定它并创建新方块\n      const shape = TETRIS_SHAPES[block.type];\n      let hitBottom = false;\n      \n      // 检查是否触底\n      for (let y = 0; y < shape.length; y++) {\n        for (let x = 0; x < shape[y].length; x++) {\n          if (shape[y][x] === 0) continue;\n          \n          const gridY = block.y + y;\n          const gridX = block.x + x;\n          \n          // 检查是否到达底部或碰到其他方块\n          if (gridY >= rows || (gridY >= 0 && tetrisGrid[gridY][gridX] !== 0)) {\n            hitBottom = true;\n            break;\n          }\n        }\n        if (hitBottom) break;\n      }\n      \n      // 如果触底，将方块固定到网格\n      if (hitBottom) {\n        // 回退一步\n        block.y -= 1;\n        \n        // 将方块添加到网格\n        for (let y = 0; y < shape.length; y++) {\n          for (let x = 0; x < shape[y].length; x++) {\n            if (shape[y][x] === 0) continue;\n            \n            const gridY = block.y + y;\n            const gridX = block.x + x;\n            \n            if (gridY >= 0 && gridY < rows && gridX >= 0 && gridX < cols) {\n              tetrisGrid[gridY][gridX] = 1;\n            }\n          }\n        }\n      }\n    });\n    \n    // 删除已固定的方块\n    activeBlocks = activeBlocks.filter(block => {\n      const shape = TETRIS_SHAPES[block.type];\n      for (let y = 0; y < shape.length; y++) {\n        for (let x = 0; x < shape[y].length; x++) {\n          if (shape[y][x] === 0) continue;\n          \n          const gridY = block.y + y;\n          const gridX = block.x + x;\n          \n          // 如果方块已经添加到网格中，则删除它\n          if (gridY >= 0 && gridY < rows && gridX >= 0 && gridX < cols && tetrisGrid[gridY][gridX] === 1) {\n            return false;\n          }\n        }\n      }\n      return true;\n    });\n    \n    // 清除完整的行\n    for (let y = rows - 1; y >= 0; y--) {\n      if (tetrisGrid[y].every(cell => cell === 1)) {\n        // 移除该行\n        tetrisGrid.splice(y, 1);\n        // 在顶部添加新行\n        tetrisGrid.unshift(Array(cols).fill(0));\n      }\n    }\n    \n    // 根据音量随机添加新方块\n    if (Math.random() < 0.1 * normalizedFreq) {\n      activeBlocks.push(createTetrisBlock(cols, startColor, endColor));\n    }\n  }\n  \n  // 清除画布\n  ctx.clearRect(0, 0, width, height);\n  \n  // 绘制网格背景\n  ctx.fillStyle = '#111';\n  ctx.fillRect(offsetX, offsetY, gridWidth, gridHeight);\n  \n  // 绘制边框\n  ctx.strokeStyle = '#333';\n  ctx.lineWidth = 2;\n  ctx.strokeRect(offsetX, offsetY, gridWidth, gridHeight);\n  \n  // 绘制固定方块\n  for (let y = 0; y < rows; y++) {\n    for (let x = 0; x < cols; x++) {\n      if (tetrisGrid[y][x] === 1) {\n        const cellX = offsetX + x * cellSize;\n        const cellY = offsetY + y * cellSize;\n        \n        // 根据频率选择颜色\n        const freqIndex = (x + y) % frequencies.length;\n        const colorPercent = frequencies[freqIndex] / 255;\n        const color = getGradientColor(startColor, endColor, colorPercent);\n        \n        ctx.fillStyle = color;\n        ctx.fillRect(cellX, cellY, cellSize - 1, cellSize - 1);\n      }\n    }\n  }\n  \n  // 绘制活动方块\n  activeBlocks.forEach(block => {\n    const shape = TETRIS_SHAPES[block.type];\n    \n    for (let y = 0; y < shape.length; y++) {\n      for (let x = 0; x < shape[y].length; x++) {\n        if (shape[y][x] === 0) continue;\n        \n        const cellX = offsetX + (block.x + x) * cellSize;\n        const cellY = offsetY + (block.y + y) * cellSize;\n        \n        if (\n          cellX >= offsetX && \n          cellX < offsetX + gridWidth && \n          cellY >= offsetY && \n          cellY < offsetY + gridHeight\n        ) {\n          ctx.fillStyle = block.color;\n          ctx.fillRect(cellX, cellY, cellSize - 1, cellSize - 1);\n        }\n      }\n    }\n  });\n};\n\n// 卡通嘴型同步\n// 存储嘴型状态\nlet mouthRadius = 0;\nlet eyeState = 0;\nlet blinkCounter = 0;\n\n// 绘制卡通人物嘴型同步效果\nexport const drawLipSync = (\n  ctx: CanvasRenderingContext2D,\n  frequencies: Uint8Array,\n  waveform: Float32Array,\n  width: number,\n  height: number,\n  options: {\n    faceColor?: string;\n    lipColor?: string;\n  } = {}\n) => {\n  const {\n    faceColor = '#ffcc99',\n    lipColor = '#ff6666'\n  } = options;\n  \n  // 清除画布\n  ctx.clearRect(0, 0, width, height);\n  \n  const centerX = width / 2;\n  const centerY = height / 2;\n  const faceSize = Math.min(width, height) * 0.6;\n  \n  // 计算平均音量和低频强度\n  let avgVolume = 0;\n  let bassIntensity = 0;\n  \n  // 获取低频能量（嘴巴张开程度）\n  for (let i = 0; i < 10; i++) {\n    bassIntensity += frequencies[i] / 255;\n  }\n  bassIntensity /= 10;\n  \n  // 获取总体音量（表情活跃度）\n  for (let i = 0; i < frequencies.length; i++) {\n    avgVolume += frequencies[i] / 255;\n  }\n  avgVolume /= frequencies.length;\n  \n  // 平滑嘴型变化\n  mouthRadius = mouthRadius * 0.7 + bassIntensity * 0.3 * faceSize * 0.3;\n  \n  // 眨眼控制\n  blinkCounter++;\n  if (blinkCounter > 120 || (avgVolume > 0.7 && Math.random() > 0.7)) {\n    eyeState = (eyeState + 1) % 3;\n    if (eyeState === 0) {\n      blinkCounter = 0;\n    }\n  }\n  \n  // 绘制脸部\n  ctx.fillStyle = faceColor;\n  ctx.beginPath();\n  ctx.arc(centerX, centerY, faceSize / 2, 0, Math.PI * 2);\n  ctx.fill();\n  \n  // 绘制嘴巴\n  ctx.fillStyle = lipColor;\n  ctx.beginPath();\n  ctx.ellipse(\n    centerX, \n    centerY + faceSize * 0.15, \n    mouthRadius * 1.5, \n    mouthRadius, \n    0, \n    0, \n    Math.PI * 2\n  );\n  ctx.fill();\n  \n  // 绘制嘴内（黑色）\n  ctx.fillStyle = '#000';\n  ctx.beginPath();\n  ctx.ellipse(\n    centerX, \n    centerY + faceSize * 0.15, \n    mouthRadius * 1.2, \n    mouthRadius * 0.7, \n    0, \n    0, \n    Math.PI * 2\n  );\n  ctx.fill();\n  \n  // 根据波形绘制舌头\n  let tongueHeight = 0;\n  for (let i = 0; i < waveform.length; i += 10) {\n    tongueHeight += Math.abs(waveform[i]);\n  }\n  tongueHeight = tongueHeight / (waveform.length / 10) * mouthRadius * 0.8;\n  \n  if (tongueHeight > 0.01) {\n    ctx.fillStyle = '#ff9999';\n    ctx.beginPath();\n    ctx.ellipse(\n      centerX, \n      centerY + faceSize * 0.15 + mouthRadius * 0.2, \n      mouthRadius * 0.8, \n      tongueHeight, \n      0, \n      0, \n      Math.PI\n    );\n    ctx.fill();\n  }\n  \n  // 绘制眼睛\n  const eyeX1 = centerX - faceSize * 0.15;\n  const eyeX2 = centerX + faceSize * 0.15;\n  const eyeY = centerY - faceSize * 0.1;\n  const eyeSize = faceSize * 0.1;\n  \n  // 眼白\n  ctx.fillStyle = '#ffffff';\n  ctx.beginPath();\n  ctx.arc(eyeX1, eyeY, eyeSize, 0, Math.PI * 2);\n  ctx.fill();\n  \n  ctx.beginPath();\n  ctx.arc(eyeX2, eyeY, eyeSize, 0, Math.PI * 2);\n  ctx.fill();\n  \n  // 眼珠（根据音频移动）\n  const eyeMoveX = (frequencies[15] / 255 - 0.5) * eyeSize * 0.5;\n  const eyeMoveY = (frequencies[20] / 255 - 0.5) * eyeSize * 0.5;\n  \n  if (eyeState === 0) {\n    // 正常眼睛\n    ctx.fillStyle = '#000000';\n    ctx.beginPath();\n    ctx.arc(eyeX1 + eyeMoveX, eyeY + eyeMoveY, eyeSize * 0.4, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.beginPath();\n    ctx.arc(eyeX2 + eyeMoveX, eyeY + eyeMoveY, eyeSize * 0.4, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // 眼神反光\n    ctx.fillStyle = '#ffffff';\n    ctx.beginPath();\n    ctx.arc(eyeX1 + eyeMoveX + eyeSize * 0.1, eyeY + eyeMoveY - eyeSize * 0.1, eyeSize * 0.1, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.beginPath();\n    ctx.arc(eyeX2 + eyeMoveX + eyeSize * 0.1, eyeY + eyeMoveY - eyeSize * 0.1, eyeSize * 0.1, 0, Math.PI * 2);\n    ctx.fill();\n  } else if (eyeState === 1) {\n    // 半闭眼\n    ctx.fillStyle = '#000000';\n    ctx.beginPath();\n    ctx.ellipse(eyeX1, eyeY, eyeSize * 0.4, eyeSize * 0.1, 0, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.beginPath();\n    ctx.ellipse(eyeX2, eyeY, eyeSize * 0.4, eyeSize * 0.1, 0, 0, Math.PI * 2);\n    ctx.fill();\n  } else {\n    // 闭眼\n    ctx.strokeStyle = '#000000';\n    ctx.lineWidth = 2;\n    \n    ctx.beginPath();\n    ctx.moveTo(eyeX1 - eyeSize * 0.5, eyeY);\n    ctx.lineTo(eyeX1 + eyeSize * 0.5, eyeY);\n    ctx.stroke();\n    \n    ctx.beginPath();\n    ctx.moveTo(eyeX2 - eyeSize * 0.5, eyeY);\n    ctx.lineTo(eyeX2 + eyeSize * 0.5, eyeY);\n    ctx.stroke();\n  }\n  \n  // 绘制眉毛（随着高频变化）\n  const browRaise = Math.max(0, frequencies[30] / 255 - 0.5) * faceSize * 0.1;\n  \n  ctx.strokeStyle = '#000000';\n  ctx.lineWidth = 3;\n  \n  // 左眉毛\n  ctx.beginPath();\n  ctx.moveTo(eyeX1 - eyeSize * 1.2, eyeY - eyeSize * 1.2 - browRaise);\n  ctx.lineTo(eyeX1 + eyeSize * 0.8, eyeY - eyeSize - browRaise * 0.5);\n  ctx.stroke();\n  \n  // 右眉毛\n  ctx.beginPath();\n  ctx.moveTo(eyeX2 + eyeSize * 1.2, eyeY - eyeSize * 1.2 - browRaise);\n  ctx.lineTo(eyeX2 - eyeSize * 0.8, eyeY - eyeSize - browRaise * 0.5);\n  ctx.stroke();\n  \n  // 根据音量添加表情变化（脸红）\n  if (avgVolume > 0.6) {\n    ctx.fillStyle = 'rgba(255, 150, 150, 0.3)';\n    ctx.beginPath();\n    ctx.arc(centerX - faceSize * 0.25, centerY + faceSize * 0.05, faceSize * 0.12, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.beginPath();\n    ctx.arc(centerX + faceSize * 0.25, centerY + faceSize * 0.05, faceSize * 0.12, 0, Math.PI * 2);\n    ctx.fill();\n  }\n  \n  // 绘制音符（在强拍时）\n  if (avgVolume > 0.65 && Math.random() > 0.7) {\n    const noteSize = faceSize * 0.15;\n    const noteX = centerX + faceSize * 0.6 * (Math.random() * 2 - 1);\n    const noteY = centerY - faceSize * 0.7;\n    \n    ctx.fillStyle = '#9c27b0';\n    ctx.beginPath();\n    ctx.ellipse(noteX, noteY, noteSize * 0.6, noteSize * 0.4, Math.PI * 0.25, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.strokeStyle = '#9c27b0';\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.moveTo(noteX + noteSize * 0.5, noteY);\n    ctx.lineTo(noteX + noteSize * 0.5, noteY - noteSize * 1.2);\n    ctx.stroke();\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}