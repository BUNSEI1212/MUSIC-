{"ast":null,"code":"// 定义常用的可视化效果\n\n// 颜色工具\nexport const getGradientColor = (startColor, endColor, percent) => {\n  // 解析颜色\n  const start = {\n    r: parseInt(startColor.slice(1, 3), 16),\n    g: parseInt(startColor.slice(3, 5), 16),\n    b: parseInt(startColor.slice(5, 7), 16)\n  };\n  const end = {\n    r: parseInt(endColor.slice(1, 3), 16),\n    g: parseInt(endColor.slice(3, 5), 16),\n    b: parseInt(endColor.slice(5, 7), 16)\n  };\n\n  // 计算渐变颜色\n  const r = Math.floor(start.r + percent * (end.r - start.r));\n  const g = Math.floor(start.g + percent * (end.g - start.g));\n  const b = Math.floor(start.b + percent * (end.b - start.b));\n\n  // 转换为十六进制\n  return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n};\n\n// 频谱柱状图\nexport const drawSpectrumBars = (ctx, frequencies, width, height, options = {}) => {\n  const {\n    barWidth = 5,\n    barSpacing = 2,\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    minHeight = 5,\n    maxFreq = frequencies.length * 0.75 // 只显示频率范围的75%，高频部分通常人耳听不到\n  } = options;\n  ctx.clearRect(0, 0, width, height);\n  const totalBars = Math.min(Math.floor(width / (barWidth + barSpacing)), maxFreq);\n  const frequencyStep = Math.floor(frequencies.length / totalBars);\n  for (let i = 0; i < totalBars; i++) {\n    // 使用对数分布使低频更加清晰\n    const index = Math.floor(Math.pow(i / totalBars, 2) * maxFreq);\n    const value = frequencies[index] / 255; // 归一化到0-1\n\n    const barHeight = Math.max(minHeight, value * height);\n    const x = i * (barWidth + barSpacing);\n    const y = height - barHeight;\n\n    // 根据频率和音量生成颜色\n    const colorPercent = value;\n    const barColor = getGradientColor(startColor, endColor, colorPercent);\n    ctx.fillStyle = barColor;\n    ctx.fillRect(x, y, barWidth, barHeight);\n  }\n};\n\n// 波形图\nexport const drawWaveform = (ctx, waveform, width, height, options = {}) => {\n  const {\n    lineWidth = 2,\n    color = '#ba68c8',\n    filled = false,\n    mirror = false\n  } = options;\n  ctx.clearRect(0, 0, width, height);\n  ctx.lineWidth = lineWidth;\n  ctx.strokeStyle = color;\n  ctx.fillStyle = color;\n  const centerY = height / 2;\n  const step = Math.ceil(waveform.length / width);\n  ctx.beginPath();\n  if (filled) {\n    ctx.moveTo(0, centerY);\n  }\n  for (let i = 0; i < width; i++) {\n    const index = Math.floor(i * step);\n    const value = waveform[index];\n\n    // 计算y坐标，波形值范围是-1到1\n    const y = mirror ? centerY + value * centerY // 将波形映射到整个高度\n    : centerY + value * (centerY * 0.8); // 留出一些边距\n\n    if (i === 0) {\n      ctx.moveTo(i, y);\n    } else {\n      ctx.lineTo(i, y);\n    }\n  }\n  if (filled) {\n    ctx.lineTo(width, centerY);\n    ctx.fill();\n  } else {\n    ctx.stroke();\n  }\n};\n\n// 圆形频谱\nexport const drawCircularSpectrum = (ctx, frequencies, width, height, options = {}) => {\n  const {\n    radius = Math.min(width, height) / 3,\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    lineWidth = 2,\n    rotation = 0\n  } = options;\n  ctx.clearRect(0, 0, width, height);\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const maxBars = 180; // 圆周上的点数\n  const step = Math.ceil(frequencies.length / maxBars);\n  for (let i = 0; i < maxBars; i++) {\n    const index = Math.floor(i * step);\n    const value = frequencies[index] / 255; // 归一化到0-1\n\n    const barLength = radius * (0.5 + value * 0.5); // 长度在半径的50%-100%之间变化\n    const angle = i / maxBars * Math.PI * 2 + rotation;\n    const x1 = centerX + Math.cos(angle) * radius;\n    const y1 = centerY + Math.sin(angle) * radius;\n    const x2 = centerX + Math.cos(angle) * (radius + barLength);\n    const y2 = centerY + Math.sin(angle) * (radius + barLength);\n    const color = getGradientColor(startColor, endColor, value);\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n  }\n};\n\n// 粒子系统\n\nexport const createParticles = (count, width, height, options = {}) => {\n  const {\n    minSize = 2,\n    maxSize = 8,\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    maxSpeed = 2,\n    baseLife = 100\n  } = options;\n  const particles = [];\n  for (let i = 0; i < count; i++) {\n    const percent = Math.random();\n    const size = minSize + Math.random() * (maxSize - minSize);\n    particles.push({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      size,\n      color: getGradientColor(startColor, endColor, percent),\n      speed: Math.random() * maxSpeed,\n      angle: Math.random() * Math.PI * 2,\n      life: baseLife + Math.random() * baseLife,\n      opacity: 0.7 + Math.random() * 0.3\n    });\n  }\n  return particles;\n};\nexport const updateParticles = (particles, width, height, volume) => {\n  return particles.map(particle => {\n    // 根据音量调整速度\n    const adjustedSpeed = particle.speed * (1 + volume * 3);\n\n    // 更新位置\n    const newX = particle.x + Math.cos(particle.angle) * adjustedSpeed;\n    const newY = particle.y + Math.sin(particle.angle) * adjustedSpeed;\n\n    // 如果粒子离开画布，将其重置到另一边\n    const x = newX < 0 ? width : newX > width ? 0 : newX;\n    const y = newY < 0 ? height : newY > height ? 0 : newY;\n\n    // 递减生命值\n    const life = particle.life - 1;\n\n    // 如果生命值用完，重新创建粒子\n    if (life <= 0) {\n      return {\n        x: Math.random() * width,\n        y: Math.random() * height,\n        size: particle.size,\n        color: particle.color,\n        speed: particle.speed,\n        angle: Math.random() * Math.PI * 2,\n        life: 100 + Math.random() * 100,\n        opacity: 0.7 + Math.random() * 0.3\n      };\n    }\n    return {\n      ...particle,\n      x,\n      y,\n      life\n    };\n  });\n};\nexport const drawParticles = (ctx, particles, volume) => {\n  particles.forEach(particle => {\n    // 根据音量和生命值调整大小和不透明度\n    const sizeMultiplier = 1 + volume * 2;\n    const size = particle.size * sizeMultiplier;\n    const opacity = particle.opacity * particle.life / 200;\n    ctx.globalAlpha = opacity;\n    ctx.fillStyle = particle.color;\n    ctx.beginPath();\n    ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);\n    ctx.fill();\n  });\n  ctx.globalAlpha = 1;\n};\n\n// 存储音频瀑布图的历史数据\nlet waterfallHistory = [];\n\n// 音频瀑布图\nexport const drawAudioWaterfall = (ctx, frequencies, width, height, options = {}) => {\n  const {\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    speed = 2\n  } = options;\n  const frequencyBins = 64; // 采样的频率点数\n  const step = Math.floor(frequencies.length / frequencyBins);\n\n  // 如果历史数据为空，初始化\n  if (waterfallHistory.length === 0) {\n    for (let i = 0; i < Math.floor(height / speed); i++) {\n      const row = Array(frequencyBins).fill(0);\n      waterfallHistory.push(row);\n    }\n  }\n\n  // 获取当前帧的频率数据\n  const currentFrame = [];\n  for (let i = 0; i < frequencyBins; i++) {\n    const index = Math.floor(i * step);\n    currentFrame.push(frequencies[index] / 255); // 归一化到0-1\n  }\n\n  // 更新历史数据\n  waterfallHistory.unshift(currentFrame);\n  if (waterfallHistory.length > Math.floor(height / speed)) {\n    waterfallHistory.pop();\n  }\n\n  // 清除画布\n  ctx.clearRect(0, 0, width, height);\n\n  // 绘制瀑布图\n  const binWidth = width / frequencyBins;\n  waterfallHistory.forEach((row, rowIndex) => {\n    const y = rowIndex * speed;\n    row.forEach((value, binIndex) => {\n      const x = binIndex * binWidth;\n      const color = getGradientColor(startColor, endColor, value);\n      ctx.fillStyle = color;\n      ctx.globalAlpha = 0.8;\n      ctx.fillRect(x, y, binWidth, speed);\n    });\n  });\n  ctx.globalAlpha = 1;\n};\n\n// 万花筒效果\nexport const drawKaleidoscope = (ctx, frequencies, width, height, options = {}) => {\n  const {\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    segments = 8,\n    rotation = 0\n  } = options;\n\n  // 清除画布\n  ctx.clearRect(0, 0, width, height);\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const radius = Math.min(centerX, centerY) * 0.8;\n\n  // 保存当前状态\n  ctx.save();\n  ctx.translate(centerX, centerY);\n  ctx.rotate(rotation);\n\n  // 创建一个基本图形\n  const basePattern = ctx => {\n    const frequencyBins = 32;\n    const step = Math.floor(frequencies.length / frequencyBins);\n    for (let i = 0; i < frequencyBins; i++) {\n      const index = Math.floor(i * step);\n      const value = frequencies[index] / 255; // 归一化到0-1\n\n      const angle = i / frequencyBins * Math.PI * 2 / segments;\n      const length = radius * value;\n      const x = Math.cos(angle) * length;\n      const y = Math.sin(angle) * length;\n      const color = getGradientColor(startColor, endColor, value);\n      ctx.fillStyle = color;\n      ctx.beginPath();\n      ctx.arc(x, y, 5 + value * 15, 0, Math.PI * 2);\n      ctx.fill();\n\n      // 连接到中心的线\n      ctx.strokeStyle = color;\n      ctx.lineWidth = 2;\n      ctx.globalAlpha = 0.5;\n      ctx.beginPath();\n      ctx.moveTo(0, 0);\n      ctx.lineTo(x, y);\n      ctx.stroke();\n      ctx.globalAlpha = 1;\n    }\n  };\n\n  // 绘制多个反射的图形\n  for (let s = 0; s < segments; s++) {\n    ctx.save();\n    ctx.rotate(s / segments * Math.PI * 2);\n    basePattern(ctx);\n    ctx.restore();\n  }\n\n  // 恢复状态\n  ctx.restore();\n};\n\n// 有机形态\nexport const drawOrganicForm = (ctx, frequencies, waveform, width, height, options = {}) => {\n  const {\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    complexity = 0.7\n  } = options;\n\n  // 清除画布\n  ctx.clearRect(0, 0, width, height);\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const baseRadius = Math.min(centerX, centerY) * 0.6;\n  const frequencyBins = 32;\n  const step = Math.floor(frequencies.length / frequencyBins);\n\n  // 计算平均振幅\n  let avgAmplitude = 0;\n  for (let i = 0; i < frequencies.length; i++) {\n    avgAmplitude += frequencies[i] / 255;\n  }\n  avgAmplitude /= frequencies.length;\n\n  // 绘制有机形态\n  ctx.beginPath();\n  for (let i = 0; i <= frequencyBins; i++) {\n    const angle = i / frequencyBins * Math.PI * 2;\n\n    // 使用频率数据和波形数据创建有机的变形效果\n    const freqIndex = Math.floor(i * step) % frequencies.length;\n    const waveIndex = Math.floor(i * waveform.length / frequencyBins) % waveform.length;\n    const frequency = frequencies[freqIndex] / 255;\n    const wave = (waveform[waveIndex] + 1) / 2; // 转换到0-1范围\n\n    // 结合频率和波形数据\n    const variation = frequency * wave * complexity;\n    const radius = baseRadius * (0.7 + variation * 0.5);\n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    if (i === 0) {\n      ctx.moveTo(x, y);\n    } else {\n      ctx.lineTo(x, y);\n    }\n  }\n  ctx.closePath();\n\n  // 创建渐变填充\n  const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, baseRadius);\n  gradient.addColorStop(0, startColor);\n  gradient.addColorStop(1, endColor);\n\n  // 填充和描边\n  ctx.fillStyle = gradient;\n  ctx.fill();\n  ctx.strokeStyle = getGradientColor(startColor, endColor, avgAmplitude);\n  ctx.lineWidth = 2;\n  ctx.stroke();\n};\n\n// 俄罗斯方块效果\n\n// 俄罗斯方块块类型形状\nconst TETRIS_SHAPES = [\n// I形\n[[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]],\n// J形\n[[1, 0, 0], [1, 1, 1], [0, 0, 0]],\n// L形\n[[0, 0, 1], [1, 1, 1], [0, 0, 0]],\n// O形\n[[1, 1], [1, 1]],\n// S形\n[[0, 1, 1], [1, 1, 0], [0, 0, 0]],\n// T形\n[[0, 1, 0], [1, 1, 1], [0, 0, 0]],\n// Z形\n[[1, 1, 0], [0, 1, 1], [0, 0, 0]]];\n\n// 存储当前的方块和网格\nlet tetrisGrid = [];\nlet activeBlocks = [];\nlet tetrisLastUpdate = 0;\n\n// 初始化俄罗斯方块网格\nconst initTetrisGrid = (cols, rows) => {\n  tetrisGrid = [];\n  for (let i = 0; i < rows; i++) {\n    tetrisGrid.push(Array(cols).fill(0));\n  }\n};\n\n// 创建新的方块\nconst createTetrisBlock = (cols, startColor, endColor) => {\n  const type = Math.floor(Math.random() * TETRIS_SHAPES.length);\n  const color = getGradientColor(startColor, endColor, Math.random());\n  return {\n    x: Math.floor(cols / 2) - Math.floor(TETRIS_SHAPES[type][0].length / 2),\n    y: 0,\n    type,\n    rotation: 0,\n    color\n  };\n};\n\n// 绘制俄罗斯方块效果\nexport const drawTetris = (ctx, frequencies, width, height, options = {}) => {\n  const {\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    speed = 1\n  } = options;\n\n  // 计算网格尺寸\n  const cols = 12;\n  const rows = 20;\n  const cellSize = Math.min(width / cols, height / rows);\n  const gridWidth = cols * cellSize;\n  const gridHeight = rows * cellSize;\n  const offsetX = (width - gridWidth) / 2;\n  const offsetY = (height - gridHeight) / 2;\n\n  // 初始化网格\n  if (tetrisGrid.length === 0) {\n    initTetrisGrid(cols, rows);\n  }\n\n  // 根据音频数据控制游戏速度\n  const now = Date.now();\n  const avgFreq = Array.from(frequencies).reduce((sum, val) => sum + val, 0) / frequencies.length;\n  const normalizedFreq = avgFreq / 255;\n\n  // 音量越大，方块下落越快\n  const updateInterval = 1000 - normalizedFreq * 800;\n\n  // 音量脉冲添加新方块\n  if (normalizedFreq > 0.6 && Math.random() < 0.1) {\n    activeBlocks.push(createTetrisBlock(cols, startColor, endColor));\n  }\n\n  // 更新方块位置\n  if (now - tetrisLastUpdate > updateInterval) {\n    tetrisLastUpdate = now;\n\n    // 创建初始方块\n    if (activeBlocks.length === 0) {\n      activeBlocks.push(createTetrisBlock(cols, startColor, endColor));\n    }\n\n    // 尝试移动活动方块\n    activeBlocks.forEach(block => {\n      block.y += 1;\n\n      // 如果方块触底或碰到其他方块，固定它并创建新方块\n      const shape = TETRIS_SHAPES[block.type];\n      let hitBottom = false;\n\n      // 检查是否触底\n      for (let y = 0; y < shape.length; y++) {\n        for (let x = 0; x < shape[y].length; x++) {\n          if (shape[y][x] === 0) continue;\n          const gridY = block.y + y;\n          const gridX = block.x + x;\n\n          // 检查是否到达底部或碰到其他方块\n          if (gridY >= rows || gridY >= 0 && tetrisGrid[gridY][gridX] !== 0) {\n            hitBottom = true;\n            break;\n          }\n        }\n        if (hitBottom) break;\n      }\n\n      // 如果触底，将方块固定到网格\n      if (hitBottom) {\n        // 回退一步\n        block.y -= 1;\n\n        // 将方块添加到网格\n        for (let y = 0; y < shape.length; y++) {\n          for (let x = 0; x < shape[y].length; x++) {\n            if (shape[y][x] === 0) continue;\n            const gridY = block.y + y;\n            const gridX = block.x + x;\n            if (gridY >= 0 && gridY < rows && gridX >= 0 && gridX < cols) {\n              tetrisGrid[gridY][gridX] = 1;\n            }\n          }\n        }\n      }\n    });\n\n    // 删除已固定的方块\n    activeBlocks = activeBlocks.filter(block => {\n      const shape = TETRIS_SHAPES[block.type];\n      for (let y = 0; y < shape.length; y++) {\n        for (let x = 0; x < shape[y].length; x++) {\n          if (shape[y][x] === 0) continue;\n          const gridY = block.y + y;\n          const gridX = block.x + x;\n\n          // 如果方块已经添加到网格中，则删除它\n          if (gridY >= 0 && gridY < rows && gridX >= 0 && gridX < cols && tetrisGrid[gridY][gridX] === 1) {\n            return false;\n          }\n        }\n      }\n      return true;\n    });\n\n    // 清除完整的行\n    for (let y = rows - 1; y >= 0; y--) {\n      if (tetrisGrid[y].every(cell => cell === 1)) {\n        // 移除该行\n        tetrisGrid.splice(y, 1);\n        // 在顶部添加新行\n        tetrisGrid.unshift(Array(cols).fill(0));\n      }\n    }\n\n    // 根据音量随机添加新方块\n    if (Math.random() < 0.1 * normalizedFreq) {\n      activeBlocks.push(createTetrisBlock(cols, startColor, endColor));\n    }\n  }\n\n  // 清除画布\n  ctx.clearRect(0, 0, width, height);\n\n  // 绘制网格背景\n  ctx.fillStyle = '#111';\n  ctx.fillRect(offsetX, offsetY, gridWidth, gridHeight);\n\n  // 绘制边框\n  ctx.strokeStyle = '#333';\n  ctx.lineWidth = 2;\n  ctx.strokeRect(offsetX, offsetY, gridWidth, gridHeight);\n\n  // 绘制固定方块\n  for (let y = 0; y < rows; y++) {\n    for (let x = 0; x < cols; x++) {\n      if (tetrisGrid[y][x] === 1) {\n        const cellX = offsetX + x * cellSize;\n        const cellY = offsetY + y * cellSize;\n\n        // 根据频率选择颜色\n        const freqIndex = (x + y) % frequencies.length;\n        const colorPercent = frequencies[freqIndex] / 255;\n        const color = getGradientColor(startColor, endColor, colorPercent);\n        ctx.fillStyle = color;\n        ctx.fillRect(cellX, cellY, cellSize - 1, cellSize - 1);\n      }\n    }\n  }\n\n  // 绘制活动方块\n  activeBlocks.forEach(block => {\n    const shape = TETRIS_SHAPES[block.type];\n    for (let y = 0; y < shape.length; y++) {\n      for (let x = 0; x < shape[y].length; x++) {\n        if (shape[y][x] === 0) continue;\n        const cellX = offsetX + (block.x + x) * cellSize;\n        const cellY = offsetY + (block.y + y) * cellSize;\n        if (cellX >= offsetX && cellX < offsetX + gridWidth && cellY >= offsetY && cellY < offsetY + gridHeight) {\n          ctx.fillStyle = block.color;\n          ctx.fillRect(cellX, cellY, cellSize - 1, cellSize - 1);\n        }\n      }\n    }\n  });\n};\n\n// 卡通嘴型同步\n// 存储嘴型状态\nlet mouthRadius = 0;\nlet eyeState = 0;\nlet blinkCounter = 0;\n\n// 绘制卡通人物嘴型同步效果\nexport const drawLipSync = (ctx, frequencies, waveform, width, height, options = {}) => {\n  const {\n    faceColor = '#ffcc99',\n    lipColor = '#ff6666'\n  } = options;\n\n  // 清除画布\n  ctx.clearRect(0, 0, width, height);\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const faceSize = Math.min(width, height) * 0.6;\n\n  // 计算平均音量和低频强度\n  let avgVolume = 0;\n  let bassIntensity = 0;\n\n  // 获取低频能量（嘴巴张开程度）\n  for (let i = 0; i < 10; i++) {\n    bassIntensity += frequencies[i] / 255;\n  }\n  bassIntensity /= 10;\n\n  // 获取总体音量（表情活跃度）\n  for (let i = 0; i < frequencies.length; i++) {\n    avgVolume += frequencies[i] / 255;\n  }\n  avgVolume /= frequencies.length;\n\n  // 平滑嘴型变化\n  mouthRadius = mouthRadius * 0.7 + bassIntensity * 0.3 * faceSize * 0.3;\n\n  // 眨眼控制\n  blinkCounter++;\n  if (blinkCounter > 120 || avgVolume > 0.7 && Math.random() > 0.7) {\n    eyeState = (eyeState + 1) % 3;\n    if (eyeState === 0) {\n      blinkCounter = 0;\n    }\n  }\n\n  // 绘制脸部\n  ctx.fillStyle = faceColor;\n  ctx.beginPath();\n  ctx.arc(centerX, centerY, faceSize / 2, 0, Math.PI * 2);\n  ctx.fill();\n\n  // 绘制嘴巴\n  ctx.fillStyle = lipColor;\n  ctx.beginPath();\n  ctx.ellipse(centerX, centerY + faceSize * 0.15, mouthRadius * 1.5, mouthRadius, 0, 0, Math.PI * 2);\n  ctx.fill();\n\n  // 绘制嘴内（黑色）\n  ctx.fillStyle = '#000';\n  ctx.beginPath();\n  ctx.ellipse(centerX, centerY + faceSize * 0.15, mouthRadius * 1.2, mouthRadius * 0.7, 0, 0, Math.PI * 2);\n  ctx.fill();\n\n  // 根据波形绘制舌头\n  let tongueHeight = 0;\n  for (let i = 0; i < waveform.length; i += 10) {\n    tongueHeight += Math.abs(waveform[i]);\n  }\n  tongueHeight = tongueHeight / (waveform.length / 10) * mouthRadius * 0.8;\n  if (tongueHeight > 0.01) {\n    ctx.fillStyle = '#ff9999';\n    ctx.beginPath();\n    ctx.ellipse(centerX, centerY + faceSize * 0.15 + mouthRadius * 0.2, mouthRadius * 0.8, tongueHeight, 0, 0, Math.PI);\n    ctx.fill();\n  }\n\n  // 绘制眼睛\n  const eyeX1 = centerX - faceSize * 0.15;\n  const eyeX2 = centerX + faceSize * 0.15;\n  const eyeY = centerY - faceSize * 0.1;\n  const eyeSize = faceSize * 0.1;\n\n  // 眼白\n  ctx.fillStyle = '#ffffff';\n  ctx.beginPath();\n  ctx.arc(eyeX1, eyeY, eyeSize, 0, Math.PI * 2);\n  ctx.fill();\n  ctx.beginPath();\n  ctx.arc(eyeX2, eyeY, eyeSize, 0, Math.PI * 2);\n  ctx.fill();\n\n  // 眼珠（根据音频移动）\n  const eyeMoveX = (frequencies[15] / 255 - 0.5) * eyeSize * 0.5;\n  const eyeMoveY = (frequencies[20] / 255 - 0.5) * eyeSize * 0.5;\n  if (eyeState === 0) {\n    // 正常眼睛\n    ctx.fillStyle = '#000000';\n    ctx.beginPath();\n    ctx.arc(eyeX1 + eyeMoveX, eyeY + eyeMoveY, eyeSize * 0.4, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(eyeX2 + eyeMoveX, eyeY + eyeMoveY, eyeSize * 0.4, 0, Math.PI * 2);\n    ctx.fill();\n\n    // 眼神反光\n    ctx.fillStyle = '#ffffff';\n    ctx.beginPath();\n    ctx.arc(eyeX1 + eyeMoveX + eyeSize * 0.1, eyeY + eyeMoveY - eyeSize * 0.1, eyeSize * 0.1, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(eyeX2 + eyeMoveX + eyeSize * 0.1, eyeY + eyeMoveY - eyeSize * 0.1, eyeSize * 0.1, 0, Math.PI * 2);\n    ctx.fill();\n  } else if (eyeState === 1) {\n    // 半闭眼\n    ctx.fillStyle = '#000000';\n    ctx.beginPath();\n    ctx.ellipse(eyeX1, eyeY, eyeSize * 0.4, eyeSize * 0.1, 0, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.ellipse(eyeX2, eyeY, eyeSize * 0.4, eyeSize * 0.1, 0, 0, Math.PI * 2);\n    ctx.fill();\n  } else {\n    // 闭眼\n    ctx.strokeStyle = '#000000';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(eyeX1 - eyeSize * 0.5, eyeY);\n    ctx.lineTo(eyeX1 + eyeSize * 0.5, eyeY);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.moveTo(eyeX2 - eyeSize * 0.5, eyeY);\n    ctx.lineTo(eyeX2 + eyeSize * 0.5, eyeY);\n    ctx.stroke();\n  }\n\n  // 绘制眉毛（随着高频变化）\n  const browRaise = Math.max(0, frequencies[30] / 255 - 0.5) * faceSize * 0.1;\n  ctx.strokeStyle = '#000000';\n  ctx.lineWidth = 3;\n\n  // 左眉毛\n  ctx.beginPath();\n  ctx.moveTo(eyeX1 - eyeSize * 1.2, eyeY - eyeSize * 1.2 - browRaise);\n  ctx.lineTo(eyeX1 + eyeSize * 0.8, eyeY - eyeSize - browRaise * 0.5);\n  ctx.stroke();\n\n  // 右眉毛\n  ctx.beginPath();\n  ctx.moveTo(eyeX2 + eyeSize * 1.2, eyeY - eyeSize * 1.2 - browRaise);\n  ctx.lineTo(eyeX2 - eyeSize * 0.8, eyeY - eyeSize - browRaise * 0.5);\n  ctx.stroke();\n\n  // 根据音量添加表情变化（脸红）\n  if (avgVolume > 0.6) {\n    ctx.fillStyle = 'rgba(255, 150, 150, 0.3)';\n    ctx.beginPath();\n    ctx.arc(centerX - faceSize * 0.25, centerY + faceSize * 0.05, faceSize * 0.12, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.beginPath();\n    ctx.arc(centerX + faceSize * 0.25, centerY + faceSize * 0.05, faceSize * 0.12, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  // 绘制音符（在强拍时）\n  if (avgVolume > 0.65 && Math.random() > 0.7) {\n    const noteSize = faceSize * 0.15;\n    const noteX = centerX + faceSize * 0.6 * (Math.random() * 2 - 1);\n    const noteY = centerY - faceSize * 0.7;\n    ctx.fillStyle = '#9c27b0';\n    ctx.beginPath();\n    ctx.ellipse(noteX, noteY, noteSize * 0.6, noteSize * 0.4, Math.PI * 0.25, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.strokeStyle = '#9c27b0';\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.moveTo(noteX + noteSize * 0.5, noteY);\n    ctx.lineTo(noteX + noteSize * 0.5, noteY - noteSize * 1.2);\n    ctx.stroke();\n  }\n};\n\n// 音乐流星雨\n\nlet meteors = [];\nlet lastMeteorTime = 0;\n\n// 创建流星\nconst createMeteor = (canvasWidth, canvasHeight, startColor, endColor) => {\n  const x = Math.random() * canvasWidth;\n  const y = -50; // 从画布上方开始\n  const length = 20 + Math.random() * 80;\n  const speed = 3 + Math.random() * 7;\n  const color = getGradientColor(startColor, endColor, Math.random());\n  const width = 1 + Math.random() * 3;\n  return {\n    x,\n    y,\n    length,\n    speed,\n    color,\n    width,\n    trail: []\n  };\n};\n\n// 音乐流星雨效果\nexport const drawMusicMeteorShower = (ctx, frequencies, waveform, width, height, options = {}) => {\n  const {\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    density = 1,\n    background = 'rgba(0, 0, 0, 0.05)'\n  } = options;\n\n  // 计算音频能量\n  let energy = 0;\n  for (let i = 0; i < frequencies.length; i++) {\n    energy += frequencies[i] / 255;\n  }\n  energy /= frequencies.length;\n\n  // 半透明背景，创造拖尾效果\n  ctx.fillStyle = background;\n  ctx.fillRect(0, 0, width, height);\n\n  // 生成新的流星\n  const now = Date.now();\n  const bassEnergy = frequencies.slice(0, 10).reduce((sum, val) => sum + val / 255, 0) / 10;\n\n  // 根据低频能量和密度控制流星生成频率\n  if (now - lastMeteorTime > 300 / (bassEnergy * 2 * density) && Math.random() < bassEnergy * density) {\n    meteors.push(createMeteor(width, height, startColor, endColor));\n    lastMeteorTime = now;\n  }\n\n  // 更新和绘制流星\n  meteors = meteors.filter(meteor => {\n    // 更新位置\n    meteor.y += meteor.speed * (1 + energy * 2); // 音频能量加速\n    meteor.x += meteor.speed * 0.5; // 轻微向右移动\n\n    // 存储轨迹点\n    meteor.trail.push({\n      x: meteor.x,\n      y: meteor.y\n    });\n    if (meteor.trail.length > 10) {\n      meteor.trail.shift();\n    }\n\n    // 绘制流星\n    ctx.beginPath();\n\n    // 绘制主体\n    const gradient = ctx.createLinearGradient(meteor.x, meteor.y, meteor.x, meteor.y - meteor.length);\n    gradient.addColorStop(0, meteor.color);\n    gradient.addColorStop(1, 'transparent');\n    ctx.strokeStyle = gradient;\n    ctx.lineWidth = meteor.width;\n    ctx.moveTo(meteor.x, meteor.y);\n    ctx.lineTo(meteor.x - meteor.speed * 0.5, meteor.y - meteor.length);\n    ctx.stroke();\n\n    // 绘制轨迹点\n    ctx.fillStyle = meteor.color;\n    for (let i = 0; i < meteor.trail.length; i++) {\n      const point = meteor.trail[i];\n      const size = i / meteor.trail.length * meteor.width * 0.8;\n      ctx.beginPath();\n      ctx.arc(point.x, point.y, size, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // 随机添加闪光点\n    if (Math.random() < 0.3) {\n      const sparkX = meteor.x + (Math.random() - 0.5) * 5;\n      const sparkY = meteor.y - Math.random() * meteor.length * 0.8;\n      ctx.beginPath();\n      ctx.arc(sparkX, sparkY, Math.random() * 1.5, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // 如果流星超出画布底部，则删除\n    return meteor.y < height + 100;\n  });\n\n  // 绘制星空背景\n  for (let i = 0; i < frequencies.length; i += 5) {\n    const x = i / frequencies.length * width;\n    const y = height * 0.5 + (waveform[i] || 0) * height * 0.3;\n    const intensity = frequencies[i] / 255;\n    if (intensity > 0.2) {\n      const starSize = intensity * 2;\n      ctx.fillStyle = `rgba(255, 255, 255, ${intensity * 0.7})`;\n      ctx.beginPath();\n      ctx.arc(x, y, starSize, 0, Math.PI * 2);\n      ctx.fill();\n\n      // 星星光芒\n      if (intensity > 0.7) {\n        const glowSize = starSize * 3;\n        const glow = ctx.createRadialGradient(x, y, 0, x, y, glowSize);\n        glow.addColorStop(0, `rgba(255, 255, 255, ${intensity * 0.5})`);\n        glow.addColorStop(1, 'transparent');\n        ctx.fillStyle = glow;\n        ctx.beginPath();\n        ctx.arc(x, y, glowSize, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n  }\n\n  // 在高能量时绘制北极光效果\n  if (energy > 0.5) {\n    const auroras = Math.floor(3 + energy * 4);\n    for (let i = 0; i < auroras; i++) {\n      const auroraY = height * (0.7 + Math.random() * 0.2);\n      const auroraHeight = height * 0.2 * energy;\n      const curvePoints = [];\n      const segments = 20;\n      for (let j = 0; j <= segments; j++) {\n        const px = j / segments * width;\n        // 使用音频数据波形控制高度\n        const frequencyIndex = Math.floor(j / segments * waveform.length);\n        const waveValue = waveform[frequencyIndex] || 0;\n        const py = auroraY - Math.abs(waveValue) * auroraHeight;\n        curvePoints.push({\n          x: px,\n          y: py\n        });\n      }\n\n      // 绘制平滑曲线\n      ctx.beginPath();\n      ctx.moveTo(curvePoints[0].x, curvePoints[0].y);\n      for (let j = 0; j < curvePoints.length - 1; j++) {\n        const current = curvePoints[j];\n        const next = curvePoints[j + 1];\n        const midX = (current.x + next.x) / 2;\n        const midY = (current.y + next.y) / 2;\n        ctx.quadraticCurveTo(current.x, current.y, midX, midY);\n      }\n\n      // 创建渐变\n      const gradient = ctx.createLinearGradient(0, auroraY - auroraHeight, 0, auroraY);\n      gradient.addColorStop(0, 'transparent');\n      gradient.addColorStop(0.5, getGradientColor(startColor, endColor, i / auroras));\n      gradient.addColorStop(1, 'transparent');\n      ctx.strokeStyle = gradient;\n      ctx.lineWidth = 2 + energy * 5;\n      ctx.globalAlpha = 0.7;\n      ctx.stroke();\n      ctx.globalAlpha = 1;\n    }\n  }\n};\n\n// 声音花园\n\n// 花朵管理\nlet flowers = [];\nlet leaves = [];\nlet lastFlowerTime = 0;\nlet gardenBackground = null;\n\n// 创建花朵\nconst createFlower = (width, height, startColor, endColor) => {\n  const flowerBedWidth = width * 0.8;\n  const x = width * 0.1 + Math.random() * flowerBedWidth;\n  const groundY = height * 0.85;\n  const stemLength = 50 + Math.random() * 150;\n  const y = groundY - stemLength;\n  return {\n    x,\n    y,\n    size: 10 + Math.random() * 40,\n    rotation: Math.random() * Math.PI * 2,\n    petals: 5 + Math.floor(Math.random() * 7),\n    color: getGradientColor(startColor, endColor, Math.random()),\n    stemLength,\n    stemWidth: 1 + Math.random() * 3,\n    growthStage: 0,\n    // 0-1表示生长程度\n    maxGrowth: 0.8 + Math.random() * 0.2,\n    // 最大生长程度\n    bloomSpeed: 0.001 + Math.random() * 0.003,\n    swayAngle: 0,\n    swaySpeed: 0.01 + Math.random() * 0.03\n  };\n};\n\n// 创建叶子\nconst createLeaf = (flowerX, stemLength, groundY, color) => {\n  const yPos = groundY - Math.random() * stemLength * 0.7;\n  const angle = (Math.random() > 0.5 ? 1 : -1) * (Math.PI / 4 + Math.random() * Math.PI / 4);\n  return {\n    x: flowerX,\n    y: yPos,\n    size: 10 + Math.random() * 15,\n    angle,\n    color: color\n  };\n};\n\n// 声音花园效果\nexport const drawSoundGarden = (ctx, frequencies, waveform, width, height, options = {}) => {\n  const {\n    startColor = '#FF1493',\n    // 深粉色\n    endColor = '#9370DB',\n    // 中紫色\n    flowerDensity = 1,\n    leafColor = '#4CAF50' // 绿色\n  } = options;\n  const groundY = height * 0.85;\n\n  // 初始化背景缓存\n  if (!gardenBackground) {\n    gardenBackground = ctx.createImageData(width, height);\n    const data = gardenBackground.data;\n\n    // 创建天空渐变\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const index = (y * width + x) * 4;\n\n        // 地面\n        if (y > groundY) {\n          data[index] = 121; // R\n          data[index + 1] = 85; // G\n          data[index + 2] = 72; // B\n          data[index + 3] = 255; // A\n        }\n        // 天空\n        else {\n          const skyRatio = y / groundY;\n          data[index] = Math.floor(135 * (1 - skyRatio) + 176 * skyRatio); // R\n          data[index + 1] = Math.floor(206 * (1 - skyRatio) + 224 * skyRatio); // G\n          data[index + 2] = Math.floor(235 * (1 - skyRatio) + 230 * skyRatio); // B\n          data[index + 3] = 255; // A\n        }\n      }\n    }\n  }\n\n  // 绘制背景\n  ctx.putImageData(gardenBackground, 0, 0);\n\n  // 计算音频能量\n  let energy = 0;\n  for (let i = 0; i < frequencies.length; i++) {\n    energy += frequencies[i] / 255;\n  }\n  energy /= frequencies.length;\n\n  // 获取低频能量（生长速度）\n  let bassEnergy = 0;\n  for (let i = 0; i < 10; i++) {\n    bassEnergy += frequencies[i] / 255;\n  }\n  bassEnergy /= 10;\n\n  // 根据音频能量添加新花朵\n  const now = Date.now();\n  if (now - lastFlowerTime > 2000 / flowerDensity && flowers.length < 20 * flowerDensity && Math.random() < bassEnergy * flowerDensity * 0.3) {\n    const newFlower = createFlower(width, height, startColor, endColor);\n    flowers.push(newFlower);\n\n    // 为花朵添加叶子\n    const leafCount = 1 + Math.floor(Math.random() * 3);\n    for (let i = 0; i < leafCount; i++) {\n      leaves.push(createLeaf(newFlower.x, newFlower.stemLength, groundY, leafColor));\n    }\n    lastFlowerTime = now;\n  }\n\n  // 绘制草地纹理\n  ctx.fillStyle = '#7CB342'; // 浅草绿\n  for (let x = 0; x < width; x += 4) {\n    const grassHeight = 5 + Math.sin(x * 0.1) * 3 + Math.random() * 5;\n    ctx.fillRect(x, groundY - grassHeight, 2, grassHeight);\n  }\n\n  // 绘制随机小花\n  for (let i = 0; i < 30 * flowerDensity; i++) {\n    const x = Math.random() * width;\n    const y = groundY - Math.random() * 10;\n    const size = 1 + Math.random() * 2;\n    ctx.fillStyle = getGradientColor(startColor, endColor, Math.random());\n    ctx.beginPath();\n    ctx.arc(x, y, size, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  // 按y坐标排序花朵，确保前面的花朵覆盖后面的花朵\n  flowers.sort((a, b) => a.y + a.stemLength - (b.y + b.stemLength));\n\n  // 更新和绘制花朵\n  flowers = flowers.filter(flower => {\n    // 根据音频能量更新生长阶段\n    flower.growthStage = Math.min(flower.maxGrowth, flower.growthStage + flower.bloomSpeed * (1 + bassEnergy * 3));\n\n    // 更新摇摆角度，基于高频部分\n    const highFreqEnergy = frequencies[30] / 255;\n    flower.swayAngle += flower.swaySpeed * Math.sin(Date.now() * 0.001) * (1 + highFreqEnergy);\n    flower.swayAngle *= 0.95; // 阻尼\n\n    // 花茎随着音频摇摆\n    const stemEndX = flower.x + Math.sin(flower.swayAngle) * flower.stemLength * 0.2;\n    const stemEndY = flower.y;\n\n    // 绘制花茎\n    ctx.strokeStyle = '#4CAF50';\n    ctx.lineWidth = flower.stemWidth;\n    ctx.beginPath();\n    ctx.moveTo(flower.x, groundY);\n\n    // 曲线花茎\n    const cp1x = flower.x + Math.sin(flower.swayAngle * 0.5) * flower.stemLength * 0.1;\n    const cp1y = groundY - flower.stemLength * 0.5;\n    ctx.bezierCurveTo(cp1x, cp1y, stemEndX, stemEndY + flower.stemLength * 0.3, stemEndX, stemEndY);\n    ctx.stroke();\n\n    // 只绘制生长阶段的花朵\n    if (flower.growthStage > 0.1) {\n      // 保存上下文\n      ctx.save();\n      ctx.translate(stemEndX, stemEndY);\n      ctx.rotate(flower.rotation + flower.swayAngle * 0.2);\n      const scaleFactor = flower.growthStage;\n      ctx.scale(scaleFactor, scaleFactor);\n\n      // 花芯\n      ctx.fillStyle = '#FFC107'; // 黄色花蕊\n      ctx.beginPath();\n      ctx.arc(0, 0, flower.size * 0.2, 0, Math.PI * 2);\n      ctx.fill();\n\n      // 花瓣\n      for (let i = 0; i < flower.petals; i++) {\n        const petalAngle = i / flower.petals * Math.PI * 2;\n        const petalSize = flower.size * (0.8 + Math.sin(Date.now() * 0.005 + i) * 0.05);\n        ctx.fillStyle = flower.color;\n        ctx.beginPath();\n\n        // 创建花瓣形状\n        ctx.ellipse(Math.cos(petalAngle) * flower.size * 0.5, Math.sin(petalAngle) * flower.size * 0.5, petalSize * 0.25, petalSize * 0.5, petalAngle, 0, Math.PI * 2);\n        ctx.fill();\n      }\n\n      // 恢复上下文\n      ctx.restore();\n    }\n\n    // 保持生长完成的花朵\n    return flower.growthStage < flower.maxGrowth || flower.growthStage >= flower.maxGrowth;\n  });\n\n  // 更新和绘制叶子\n  leaves = leaves.filter(leaf => {\n    ctx.save();\n    ctx.translate(leaf.x, leaf.y);\n    ctx.rotate(leaf.angle + Math.sin(Date.now() * 0.002) * 0.1);\n\n    // 绘制叶子形状\n    ctx.fillStyle = leaf.color;\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.bezierCurveTo(leaf.size * 0.5, -leaf.size * 0.5, leaf.size, -leaf.size * 0.2, leaf.size * 1.5, 0);\n    ctx.bezierCurveTo(leaf.size, leaf.size * 0.2, leaf.size * 0.5, leaf.size * 0.5, 0, 0);\n    ctx.fill();\n\n    // 叶脉\n    ctx.strokeStyle = 'rgba(0, 100, 0, 0.5)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(leaf.size, 0);\n    ctx.stroke();\n    for (let i = 1; i <= 3; i++) {\n      const y = leaf.size * 0.25 * i / 3;\n      ctx.beginPath();\n      ctx.moveTo(0, 0);\n      ctx.quadraticCurveTo(leaf.size * 0.5, y, leaf.size * 0.7, y * 0.8);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(0, 0);\n      ctx.quadraticCurveTo(leaf.size * 0.5, -y, leaf.size * 0.7, -y * 0.8);\n      ctx.stroke();\n    }\n    ctx.restore();\n\n    // 保留所有叶子\n    return true;\n  });\n\n  // 根据波形绘制蝴蝶\n  if (energy > 0.4) {\n    const butterflyCount = Math.floor(energy * 5);\n    for (let i = 0; i < butterflyCount; i++) {\n      // 使用波形作为路径\n      const timeOffset = Date.now() * 0.001 + i * 10;\n      const xPos = (Math.sin(timeOffset * 0.2) * 0.5 + 0.5) * width;\n      const yPos = groundY * 0.5 + Math.sin(timeOffset * 0.3) * groundY * 0.3;\n      const wingSize = 5 + Math.sin(timeOffset) * 5;\n      const wingAngle = Math.sin(timeOffset * 10) * 0.5;\n\n      // 蝴蝶身体\n      ctx.fillStyle = '#000';\n      ctx.beginPath();\n      ctx.ellipse(xPos, yPos, 5, 2, 0, 0, Math.PI * 2);\n      ctx.fill();\n\n      // 翅膀\n      ctx.fillStyle = getGradientColor(startColor, endColor, i / butterflyCount);\n\n      // 左翅\n      ctx.save();\n      ctx.translate(xPos, yPos);\n      ctx.rotate(-Math.PI / 4 - wingAngle);\n      ctx.beginPath();\n      ctx.ellipse(0, -wingSize, wingSize, wingSize * 2, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n\n      // 右翅\n      ctx.save();\n      ctx.translate(xPos, yPos);\n      ctx.rotate(Math.PI / 4 + wingAngle);\n      ctx.beginPath();\n      ctx.ellipse(0, -wingSize, wingSize, wingSize * 2, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n    }\n  }\n\n  // 如果音频能量高，添加阳光光束\n  if (energy > 0.6) {\n    const sunX = width * 0.8;\n    const sunY = height * 0.15;\n    const sunRadius = 40 * energy;\n\n    // 太阳\n    const sunGradient = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunRadius);\n    sunGradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');\n    sunGradient.addColorStop(0.5, 'rgba(255, 165, 0, 0.6)');\n    sunGradient.addColorStop(1, 'rgba(255, 69, 0, 0)');\n    ctx.fillStyle = sunGradient;\n    ctx.beginPath();\n    ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);\n    ctx.fill();\n\n    // 光束\n    const beamCount = Math.floor(5 + energy * 5);\n    for (let i = 0; i < beamCount; i++) {\n      const angle = i / beamCount * Math.PI * 2 + Date.now() * 0.0005;\n      const length = width * 0.5 * (0.5 + energy * 0.5);\n      const endX = sunX + Math.cos(angle) * length;\n      const endY = sunY + Math.sin(angle) * length;\n      const beamGradient = ctx.createLinearGradient(sunX, sunY, endX, endY);\n      beamGradient.addColorStop(0, 'rgba(255, 255, 0, 0.3)');\n      beamGradient.addColorStop(1, 'rgba(255, 255, 0, 0)');\n      ctx.strokeStyle = beamGradient;\n      ctx.lineWidth = 3 + energy * 10;\n      ctx.globalAlpha = 0.3;\n      ctx.beginPath();\n      ctx.moveTo(sunX, sunY);\n      ctx.lineTo(endX, endY);\n      ctx.stroke();\n      ctx.globalAlpha = 1;\n    }\n  }\n};\n\n// DNA螺旋\n\n// DNA效果配置\nlet dnaNodes = [];\nlet dnaRotation = 0;\n\n// 初始化DNA节点\nconst initDNA = (count, startColor, endColor, pairStartColor, pairEndColor) => {\n  dnaNodes = [];\n  for (let i = 0; i < count; i++) {\n    // 错开两条链的节点位置\n    const isBase = i % 2 === 0;\n    const zPos = i * 15; // 节点间距\n\n    // 为每对碱基分配颜色\n    const colorPos = Math.floor(i / 2) / (count / 2);\n    const baseColor = getGradientColor(startColor, endColor, colorPos);\n    const pairColor = getGradientColor(pairStartColor, pairEndColor, colorPos);\n    dnaNodes.push({\n      x: 0,\n      y: 0,\n      z: zPos,\n      color: isBase ? baseColor : pairColor,\n      baseColor,\n      pairColor,\n      size: 8,\n      rotation: 0\n    });\n  }\n};\n\n// DNA螺旋效果\nexport const drawDNAHelix = (ctx, frequencies, waveform, width, height, options = {}) => {\n  const {\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    pairStartColor = '#4CAF50',\n    pairEndColor = '#8BC34A',\n    rotationSpeed = 0.005,\n    density = 1,\n    background = '#000'\n  } = options;\n\n  // 初始化DNA节点\n  if (dnaNodes.length === 0) {\n    initDNA(70 * density, startColor, endColor, pairStartColor, pairEndColor);\n  }\n\n  // 清除画布并设置背景\n  ctx.fillStyle = background;\n  ctx.fillRect(0, 0, width, height);\n\n  // 计算音频能量\n  let energy = 0;\n  for (let i = 0; i < frequencies.length; i++) {\n    energy += frequencies[i] / 255;\n  }\n  energy /= frequencies.length;\n\n  // 根据音频能量更新旋转\n  dnaRotation += rotationSpeed * (1 + energy);\n\n  // 3D透视参数\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const perspective = 500;\n  const camZ = 150;\n  const helix = {\n    radius: 50 + energy * 30,\n    pitch: 100 // 螺旋节距\n  };\n\n  // 对节点按Z坐标排序，实现正确的遮挡效果\n  const sortedNodes = [...dnaNodes].sort((a, b) => b.z - a.z);\n\n  // 跟踪同一Z位置的两个节点，用于绘制连接线\n  let connectionPairs = [];\n\n  // 分析音频波形用于变形\n  const waveformEnergy = waveform.reduce((sum, val) => sum + Math.abs(val), 0) / waveform.length;\n\n  // 根据低频能量控制螺旋扭曲\n  let bassEnergy = 0;\n  for (let i = 0; i < 10; i++) {\n    bassEnergy += frequencies[i] / 255;\n  }\n  bassEnergy /= 10;\n\n  // 更新并绘制DNA节点\n  for (let i = 0; i < dnaNodes.length; i++) {\n    const node = dnaNodes[i];\n\n    // 将节点位置在螺旋上\n    const isBase = i % 2 === 0;\n    const pairIndex = isBase ? i + 1 : i - 1;\n    const hasPair = pairIndex >= 0 && pairIndex < dnaNodes.length;\n\n    // 计算螺旋位置\n    const angle = node.z / helix.pitch * Math.PI * 2 + dnaRotation;\n    const spiralRadius = helix.radius * (1 + Math.sin(angle * 3 + Date.now() * 0.001) * 0.1 * bassEnergy);\n\n    // 交错两条链的相位\n    const phaseOffset = isBase ? 0 : Math.PI;\n\n    // 添加频率数据造成的形变\n    const freqIndex = Math.floor(i / dnaNodes.length * frequencies.length);\n    const freqValue = frequencies[freqIndex] / 255;\n\n    // 根据音频数据计算节点的3D位置\n    node.x = Math.cos(angle + phaseOffset) * (spiralRadius + freqValue * 20);\n    node.y = Math.sin(angle + phaseOffset) * (spiralRadius + freqValue * 20);\n\n    // 增加波形变形\n    const waveOffset = Math.sin(Date.now() * 0.001 + i * 0.1) * waveformEnergy * 30;\n\n    // 进行视锥透视变换\n    const scale = perspective / (perspective + node.z - camZ + waveOffset);\n    const x2d = centerX + node.x * scale;\n    const y2d = centerY + node.y * scale;\n\n    // 节点大小根据距离变化\n    const nodeSize = node.size * scale * (1 + freqValue * 0.5);\n\n    // 保存投影位置用于绘制连接线\n    sortedNodes[i].x = x2d;\n    sortedNodes[i].y = y2d;\n    sortedNodes[i].size = nodeSize;\n\n    // 如果是一对中的第一个，保存它们的关系用于绘制连接线\n    if (isBase && hasPair) {\n      connectionPairs.push({\n        node1: node,\n        node2: dnaNodes[pairIndex]\n      });\n    }\n  }\n\n  // 先绘制两条螺旋骨架\n  ctx.lineWidth = 2;\n  ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';\n\n  // 第一条链\n  ctx.beginPath();\n  let firstNode = true;\n  for (let i = 0; i < sortedNodes.length; i += 2) {\n    const node = sortedNodes[i];\n    if (firstNode) {\n      ctx.moveTo(node.x, node.y);\n      firstNode = false;\n    } else {\n      ctx.lineTo(node.x, node.y);\n    }\n  }\n  ctx.stroke();\n\n  // 第二条链\n  ctx.beginPath();\n  firstNode = true;\n  for (let i = 1; i < sortedNodes.length; i += 2) {\n    const node = sortedNodes[i];\n    if (firstNode) {\n      ctx.moveTo(node.x, node.y);\n      firstNode = false;\n    } else {\n      ctx.lineTo(node.x, node.y);\n    }\n  }\n  ctx.stroke();\n\n  // 绘制连接碱基对的线\n  for (const pair of connectionPairs) {\n    const node1 = pair.node1;\n    const node2 = pair.node2;\n\n    // 计算两点的透视位置\n    const scale1 = perspective / (perspective + node1.z - camZ);\n    const x1 = centerX + node1.x * scale1;\n    const y1 = centerY + node1.y * scale1;\n    const scale2 = perspective / (perspective + node2.z - camZ);\n    const x2 = centerX + node2.x * scale2;\n    const y2 = centerY + node2.y * scale2;\n\n    // 根据频率数据改变连接线的样式\n    const pairIndex = Math.floor(node1.z / (70 * density * 15) * frequencies.length);\n    const pairFreq = pairIndex < frequencies.length ? frequencies[pairIndex] / 255 : 0;\n\n    // 绘制碱基对连接线\n    const gradient = ctx.createLinearGradient(x1, y1, x2, y2);\n    gradient.addColorStop(0, node1.baseColor);\n    gradient.addColorStop(1, node2.pairColor);\n    ctx.strokeStyle = gradient;\n    ctx.lineWidth = 1 + pairFreq * 2;\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n\n    // 在高能量时添加发光效果\n    if (pairFreq > 0.7) {\n      ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';\n      ctx.lineWidth = 1;\n      ctx.beginPath();\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y2);\n      ctx.stroke();\n    }\n  }\n\n  // 最后绘制所有节点\n  for (const node of sortedNodes) {\n    // 在高频能量大时使节点像素化\n    const freqIndex = Math.floor(node.z / (70 * density * 15) * frequencies.length);\n    const freq = freqIndex < frequencies.length ? frequencies[freqIndex] / 255 : 0;\n    if (freq > 0.8) {\n      // 像素化效果\n      const pixelSize = 2 + freq * 3;\n      for (let px = -2; px <= 2; px++) {\n        for (let py = -2; py <= 2; py++) {\n          if (Math.random() < freq * 0.8) {\n            ctx.fillStyle = node.color;\n            ctx.fillRect(node.x + px * pixelSize, node.y + py * pixelSize, pixelSize, pixelSize);\n          }\n        }\n      }\n    } else {\n      // 正常圆形节点\n      ctx.fillStyle = node.color;\n      ctx.beginPath();\n      ctx.arc(node.x, node.y, node.size, 0, Math.PI * 2);\n      ctx.fill();\n\n      // 在节点上添加高光\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';\n      ctx.beginPath();\n      ctx.arc(node.x - node.size * 0.3, node.y - node.size * 0.3, node.size * 0.2, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  // 在高能量时添加辉光效果\n  if (energy > 0.6) {\n    ctx.fillStyle = `rgba(255, 255, 255, ${energy * 0.1})`;\n    ctx.fillRect(0, 0, width, height);\n\n    // 添加光束\n    for (let i = 0; i < 5; i++) {\n      const beamX = centerX + (Math.random() - 0.5) * width * 0.8;\n      const beamY = centerY + (Math.random() - 0.5) * height * 0.8;\n      const gradient = ctx.createRadialGradient(beamX, beamY, 0, beamX, beamY, 100 * energy);\n      gradient.addColorStop(0, `rgba(255, 255, 255, ${energy * 0.3})`);\n      gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');\n      ctx.fillStyle = gradient;\n      ctx.beginPath();\n      ctx.arc(beamX, beamY, 100 * energy, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n};\n\n// 数字水纹\n\n// 存储当前的水纹和数字粒子\nlet ripples = [];\nlet dataParticles = [];\nlet lastRippleTime = 0;\n\n// 创建水纹\nconst createRipple = (posX, posY, startColor, endColor, energy) => {\n  const colorPercent = Math.random();\n  const color = getGradientColor(startColor, endColor, colorPercent);\n  const maxRadius = 100 + Math.random() * 150 * energy;\n  return {\n    x: posX,\n    y: posY,\n    radius: 0,\n    maxRadius,\n    color,\n    opacity: 0.8,\n    speed: 1 + Math.random() * 2 * energy,\n    thickness: 2 + Math.random() * 3 * energy\n  };\n};\n\n// 创建数字粒子\nconst createDataParticle = (posX, posY, startColor, endColor) => {\n  const color = getGradientColor(startColor, endColor, Math.random());\n  const chars = '01';\n  return {\n    x: posX,\n    y: posY,\n    char: chars.charAt(Math.floor(Math.random() * chars.length)),\n    color,\n    opacity: 0.5 + Math.random() * 0.5,\n    size: 10 + Math.random() * 10,\n    velocity: {\n      x: (Math.random() - 0.5) * 2,\n      y: (Math.random() - 0.5) * 2\n    }\n  };\n};\n\n// 数字水纹效果\nexport const drawDigitalRipple = (ctx, frequencies, waveform, width, height, options = {}) => {\n  const {\n    startColor = '#00bcd4',\n    endColor = '#3f51b5',\n    density = 1,\n    particleCount = 100,\n    rippleThreshold = 0.6,\n    background = 'rgba(0, 0, 0, 0.2)'\n  } = options;\n\n  // 半透明背景，形成拖尾效果\n  ctx.fillStyle = background;\n  ctx.fillRect(0, 0, width, height);\n\n  // 计算音频能量\n  let energy = 0;\n  for (let i = 0; i < frequencies.length; i++) {\n    energy += frequencies[i] / 255;\n  }\n  energy /= frequencies.length;\n\n  // 根据低频能量创建水纹\n  let bassEnergy = 0;\n  for (let i = 0; i < 10; i++) {\n    bassEnergy += frequencies[i] / 255;\n  }\n  bassEnergy /= 10;\n\n  // 创建数字粒子\n  if (dataParticles.length < particleCount * density) {\n    const newParticleCount = Math.floor(particleCount * density) - dataParticles.length;\n    for (let i = 0; i < newParticleCount; i++) {\n      dataParticles.push(createDataParticle(Math.random() * width, Math.random() * height, startColor, endColor));\n    }\n  }\n\n  // 在响应大声音时生成新的水纹\n  const now = Date.now();\n  if (bassEnergy > rippleThreshold && now - lastRippleTime > 300 / (density * bassEnergy)) {\n    // 使用波形数据确定水纹位置\n    const waveIndex = Math.floor(Math.random() * waveform.length);\n    const xPos = width * 0.5 + waveform[waveIndex] * width * 0.4;\n    const yPos = height * 0.5 + Math.random() * height * 0.4;\n    ripples.push(createRipple(xPos, yPos, startColor, endColor, bassEnergy));\n    lastRippleTime = now;\n\n    // 在水纹中心添加额外的数字粒子爆发\n    const burstCount = Math.floor(5 + bassEnergy * 15);\n    for (let i = 0; i < burstCount; i++) {\n      const particle = createDataParticle(xPos, yPos, startColor, endColor);\n      // 爆发速度更快\n      const angle = Math.random() * Math.PI * 2;\n      const speed = 2 + Math.random() * 5;\n      particle.velocity.x = Math.cos(angle) * speed;\n      particle.velocity.y = Math.sin(angle) * speed;\n      dataParticles.push(particle);\n    }\n  }\n\n  // 更新和绘制水纹\n  ripples = ripples.filter(ripple => {\n    ripple.radius += ripple.speed;\n    ripple.opacity = Math.max(0, ripple.opacity - 0.01);\n\n    // 只绘制一定不透明度的水纹\n    if (ripple.opacity > 0.05) {\n      ctx.strokeStyle = ripple.color;\n      ctx.lineWidth = ripple.thickness;\n      ctx.globalAlpha = ripple.opacity;\n\n      // 添加数字化效果\n      const segments = Math.floor(12 + energy * 12);\n      const segmentAngle = Math.PI * 2 / segments;\n\n      // 数字化水纹\n      for (let i = 0; i < segments; i++) {\n        // 扭曲各段\n        const freqIndex = Math.floor(i / segments * frequencies.length);\n        const freqValue = frequencies[freqIndex] / 255;\n        const startAngle = i * segmentAngle;\n        const endAngle = startAngle + segmentAngle;\n\n        // 扰动半径\n        const radiusVariation = 1 + freqValue * 0.3;\n        ctx.beginPath();\n        ctx.arc(ripple.x, ripple.y, ripple.radius * radiusVariation, startAngle, endAngle);\n        ctx.stroke();\n      }\n      ctx.globalAlpha = 1;\n    }\n\n    // 当水纹半径超过最大值或不透明度太低时，移除它\n    return ripple.radius < ripple.maxRadius && ripple.opacity > 0.05;\n  });\n\n  // 更新和绘制数字粒子\n  dataParticles = dataParticles.filter(particle => {\n    // 更新位置\n    particle.x += particle.velocity.x;\n    particle.y += particle.velocity.y;\n\n    // 如果离开画布，重置到另一边\n    if (particle.x < 0) particle.x = width;\n    if (particle.x > width) particle.x = 0;\n    if (particle.y < 0) particle.y = height;\n    if (particle.y > height) particle.y = 0;\n\n    // 在水纹附近的粒子受到影响\n    for (const ripple of ripples) {\n      const dx = particle.x - ripple.x;\n      const dy = particle.y - ripple.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      // 当粒子接近水纹边缘时\n      const rippleEdgeDistance = Math.abs(distance - ripple.radius);\n      if (rippleEdgeDistance < 20) {\n        // 增加粒子大小和改变颜色\n        particle.size *= 1.05;\n\n        // 给粒子加上一个指向或远离水纹中心的力\n        const angle = Math.atan2(dy, dx);\n        const force = 0.2 * (1 - rippleEdgeDistance / 20);\n        particle.velocity.x += Math.cos(angle) * force;\n        particle.velocity.y += Math.sin(angle) * force;\n\n        // 随机改变字符\n        if (Math.random() < 0.1) {\n          particle.char = Math.random() < 0.5 ? '0' : '1';\n        }\n      }\n    }\n\n    // 限制粒子速度\n    const speed = Math.sqrt(particle.velocity.x * particle.velocity.x + particle.velocity.y * particle.velocity.y);\n    if (speed > 5) {\n      particle.velocity.x = particle.velocity.x / speed * 5;\n      particle.velocity.y = particle.velocity.y / speed * 5;\n    }\n\n    // 缓慢恢复原来的大小\n    particle.size = particle.size * 0.99 + (10 + Math.random() * 10) * 0.01;\n\n    // 根据频率变化字体大小和字符\n    const freqIndex = Math.floor(particle.x / width * frequencies.length);\n    const freqValue = frequencies[freqIndex] / 255;\n    if (freqValue > 0.7 && Math.random() < 0.2) {\n      particle.char = Math.random() < 0.5 ? '0' : '1';\n    }\n\n    // 绘制数字粒子\n    ctx.font = `${Math.floor(particle.size)}px monospace`;\n    ctx.fillStyle = particle.color;\n    ctx.globalAlpha = particle.opacity;\n    ctx.fillText(particle.char, particle.x, particle.y);\n    ctx.globalAlpha = 1;\n    return true;\n  });\n\n  // 添加闪烁效果\n  const flashCount = Math.floor(energy * 10);\n  for (let i = 0; i < flashCount; i++) {\n    if (Math.random() < 0.3) {\n      const flashX = Math.random() * width;\n      const flashY = Math.random() * height;\n      ctx.fillStyle = getGradientColor(startColor, endColor, Math.random());\n      ctx.font = `${Math.floor(15 + Math.random() * 20)}px monospace`;\n      ctx.fillText(Math.random() < 0.5 ? '0' : '1', flashX, flashY);\n    }\n  }\n\n  // 在高能量时添加矩阵代码雨效果\n  if (energy > 0.7) {\n    const codeRainCount = Math.floor(10 + energy * 20);\n    for (let i = 0; i < codeRainCount; i++) {\n      const x = Math.random() * width;\n      let y = -20;\n      const columnHeight = Math.floor(5 + Math.random() * 15);\n      const charSize = 12 + Math.random() * 8;\n      for (let j = 0; j < columnHeight; j++) {\n        const charOpacity = 1 - j / columnHeight;\n        if (charOpacity > 0.1) {\n          ctx.font = `${Math.floor(charSize)}px monospace`;\n          ctx.fillStyle = `rgba(0, 255, 140, ${charOpacity})`;\n          ctx.fillText(Math.random() < 0.5 ? '0' : '1', x, y + j * charSize);\n        }\n      }\n    }\n  }\n};\n\n// 粒子文字\n\n// 存储文字粒子\nlet textParticles = [];\nlet particleText = '音楽';\nlet textSize = 80;\nlet textInitialized = false;\n\n// 初始化文字粒子\nconst initTextParticles = (ctx, text, size, width, height, startColor, endColor) => {\n  // 调整文本位置\n  ctx.font = `bold ${size}px Arial`;\n  ctx.textAlign = 'center';\n\n  // 清除之前的粒子\n  textParticles = [];\n\n  // 创建临时画布用于获取文本像素\n  const tempCanvas = document.createElement('canvas');\n  const tempCtx = tempCanvas.getContext('2d');\n  if (!tempCtx) return;\n  tempCanvas.width = width;\n  tempCanvas.height = height;\n\n  // 在临时画布上绘制文本\n  tempCtx.font = `bold ${size}px Arial`;\n  tempCtx.fillStyle = '#ffffff';\n  tempCtx.textAlign = 'center';\n  tempCtx.textBaseline = 'middle';\n  tempCtx.fillText(text, width / 2, height / 2);\n\n  // 获取像素数据\n  const imageData = tempCtx.getImageData(0, 0, width, height).data;\n\n  // 采样步长（调整以控制粒子数量）\n  const sampleStep = 4 + Math.floor(size / 30);\n\n  // 创建文字粒子\n  for (let y = 0; y < height; y += sampleStep) {\n    for (let x = 0; x < width; x += sampleStep) {\n      const index = (y * width + x) * 4;\n      // 只为不透明像素创建粒子\n      if (imageData[index + 3] > 128) {\n        const colorPos = Math.random();\n        const color = getGradientColor(startColor, endColor, colorPos);\n        textParticles.push({\n          x: width / 2 + (Math.random() - 0.5) * width,\n          y: height / 2 + (Math.random() - 0.5) * height,\n          originX: x,\n          originY: y,\n          color,\n          size: 1 + Math.random() * 3,\n          dx: 0,\n          dy: 0,\n          vx: 0,\n          vy: 0,\n          force: 0,\n          angle: 0,\n          distance: 0,\n          random: Math.random(),\n          alpha: 0,\n          brightness: 0\n        });\n      }\n    }\n  }\n  textInitialized = true;\n};\n\n// 粒子文字效果\nexport const drawParticleText = (ctx, frequencies, waveform, width, height, options = {}) => {\n  const {\n    text = '音楽',\n    startColor = '#ff4081',\n    endColor = '#7c4dff',\n    particleSize = 2,\n    textSize: customTextSize = 80,\n    easeDistance = 8,\n    interactive = true,\n    background = 'rgba(0, 0, 0, 0.05)'\n  } = options;\n\n  // 如果文字或大小改变，重新初始化粒子\n  if (!textInitialized || particleText !== text || textSize !== customTextSize) {\n    particleText = text;\n    textSize = customTextSize;\n    initTextParticles(ctx, text, textSize, width, height, startColor, endColor);\n  }\n\n  // 绘制半透明背景\n  ctx.fillStyle = background;\n  ctx.fillRect(0, 0, width, height);\n\n  // 计算音频能量\n  let energy = 0;\n  for (let i = 0; i < frequencies.length; i++) {\n    energy += frequencies[i] / 255;\n  }\n  energy /= frequencies.length;\n\n  // 获取低频能量\n  let bassEnergy = 0;\n  for (let i = 0; i < 10; i++) {\n    bassEnergy += frequencies[i] / 255;\n  }\n  bassEnergy /= 10;\n\n  // 获取高频能量\n  let highEnergy = 0;\n  for (let i = frequencies.length - 20; i < frequencies.length; i++) {\n    highEnergy += frequencies[i] / 255;\n  }\n  highEnergy /= 20;\n\n  // 创建鼠标交互的影响\n  const mouseX = width / 2;\n  const mouseY = height / 2;\n\n  // 根据音频波形创建波动效果\n  const waveX = Math.sin(Date.now() * 0.001) * width * 0.1;\n  const waveY = Math.cos(Date.now() * 0.001) * height * 0.1;\n\n  // 更新和绘制所有粒子\n  for (let i = 0; i < textParticles.length; i++) {\n    const particle = textParticles[i];\n\n    // 调整目标位置，添加基于频率的扰动\n    const frequencyIndex = Math.floor(i / textParticles.length * frequencies.length);\n    const frequencyValue = frequencies[frequencyIndex] / 255;\n\n    // 根据频率调整粒子的目标位置\n    const targetX = particle.originX + waveX * frequencyValue * 2;\n    const targetY = particle.originY + waveY * frequencyValue * 2;\n\n    // 计算距离\n    particle.dx = targetX - particle.x;\n    particle.dy = targetY - particle.y;\n    particle.distance = Math.sqrt(particle.dx * particle.dx + particle.dy * particle.dy);\n\n    // 力的计算\n    particle.force = -easeDistance * (1 - particle.distance / easeDistance);\n\n    // 如果粒子接近目标位置，减小力\n    if (particle.distance < easeDistance) {\n      particle.force = (particle.distance - easeDistance) * (particle.random * 0.1 + 0.12);\n    }\n\n    // 计算角度\n    particle.angle = Math.atan2(particle.dy, particle.dx);\n\n    // 应用力\n    particle.vx += Math.cos(particle.angle) * particle.force;\n    particle.vy += Math.sin(particle.angle) * particle.force;\n\n    // 添加鼠标/触摸交互\n    if (interactive) {\n      // 计算到鼠标位置的距离\n      const mouseForceRadius = 50 * (1 + bassEnergy);\n      const dx = particle.x - mouseX - waveX * bassEnergy * 10;\n      const dy = particle.y - mouseY - waveY * bassEnergy * 10;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      // 施加鼠标斥力\n      if (distance < mouseForceRadius) {\n        const angle = Math.atan2(dy, dx);\n        const force = (mouseForceRadius - distance) / mouseForceRadius;\n        particle.vx += Math.cos(angle) * force * (1 + bassEnergy * 10);\n        particle.vy += Math.sin(angle) * force * (1 + bassEnergy * 10);\n      }\n    }\n\n    // 添加随机性\n    particle.vx += (Math.random() - 0.5) * (0.1 + highEnergy * 0.2);\n    particle.vy += (Math.random() - 0.5) * (0.1 + highEnergy * 0.2);\n\n    // 阻尼\n    particle.vx *= 0.92;\n    particle.vy *= 0.92;\n\n    // 更新位置\n    particle.x += particle.vx;\n    particle.y += particle.vy;\n\n    // 计算不透明度（基于到原点的距离）\n    particle.alpha = Math.min(1, 1 - particle.distance / 200);\n    if (particle.alpha < 0) particle.alpha = 0;\n\n    // 根据音频数据调整亮度\n    particle.brightness = 0.8 + frequencyValue * 0.5;\n\n    // 在高能量时添加脉冲效果\n    if (energy > 0.7 && Math.random() < 0.2) {\n      particle.size = particleSize * (1 + Math.random() * 2);\n      particle.brightness = 1.5;\n    } else {\n      // 缓慢恢复原来的大小\n      particle.size = particle.size * 0.95 + particleSize * 0.05;\n    }\n\n    // 绘制粒子\n    ctx.globalAlpha = particle.alpha;\n    ctx.fillStyle = particle.color;\n\n    // 根据能量决定是否绘制为圆形或正方形\n    if (energy > 0.6 && Math.random() < 0.3) {\n      // 正方形\n      const size = particle.size * 1.2 * particle.brightness;\n      ctx.fillRect(particle.x - size / 2, particle.y - size / 2, size, size);\n    } else {\n      // 圆形\n      ctx.beginPath();\n      ctx.arc(particle.x, particle.y, particle.size * particle.brightness, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // 高能量时添加连接线\n    if (energy > 0.8) {\n      // 查找临近粒子并连线\n      for (let j = i + 1; j < textParticles.length; j++) {\n        const otherParticle = textParticles[j];\n        const dx = particle.x - otherParticle.x;\n        const dy = particle.y - otherParticle.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        if (distance < 25) {\n          ctx.globalAlpha = (1 - distance / 25) * 0.2 * particle.alpha * otherParticle.alpha;\n          ctx.strokeStyle = particle.color;\n          ctx.lineWidth = 0.5;\n          ctx.beginPath();\n          ctx.moveTo(particle.x, particle.y);\n          ctx.lineTo(otherParticle.x, otherParticle.y);\n          ctx.stroke();\n        }\n      }\n    }\n  }\n\n  // 重置全局透明度\n  ctx.globalAlpha = 1;\n\n  // 添加整体模糊效果\n  if (energy > 0.5) {\n    ctx.fillStyle = `rgba(0, 0, 0, ${0.05 * energy})`;\n    ctx.fillRect(0, 0, width, height);\n  }\n\n  // 在高能量时添加闪烁效果\n  if (energy > 0.7) {\n    for (let i = 0; i < 10; i++) {\n      if (Math.random() < 0.2) {\n        const x = Math.random() * width;\n        const y = Math.random() * height;\n        const size = 1 + Math.random() * 3;\n        ctx.fillStyle = getGradientColor(startColor, endColor, Math.random());\n        ctx.beginPath();\n        ctx.arc(x, y, size, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n  }\n};\n\n// 注释掉新添加的效果类型\nvar VisualizationType = /*#__PURE__*/function (VisualizationType) {\n  VisualizationType[\"SPECTRUM_BARS\"] = \"spectrumBars\";\n  VisualizationType[\"WAVEFORM\"] = \"waveform\";\n  VisualizationType[\"CIRCULAR\"] = \"circular\";\n  VisualizationType[\"PARTICLES\"] = \"particles\";\n  VisualizationType[\"KALEIDOSCOPE\"] = \"kaleidoscope\";\n  VisualizationType[\"AUDIO_WATERFALL\"] = \"audioWaterfall\";\n  VisualizationType[\"ORGANIC_FORM\"] = \"organicForm\";\n  VisualizationType[\"TETRIS\"] = \"tetris\";\n  VisualizationType[\"LIP_SYNC\"] = \"lipSync\"; // 暂时注释掉新添加的效果\n  // MUSIC_METEOR = 'musicMeteor',\n  // SOUND_GARDEN = 'soundGarden',\n  // DNA_HELIX = 'dnaHelix',\n  // DIGITAL_RIPPLE = 'digitalRipple',\n  // PARTICLE_TEXT = 'particleText'\n  return VisualizationType;\n}(VisualizationType || {});","map":{"version":3,"names":["getGradientColor","startColor","endColor","percent","start","r","parseInt","slice","g","b","end","Math","floor","toString","padStart","drawSpectrumBars","ctx","frequencies","width","height","options","barWidth","barSpacing","minHeight","maxFreq","length","clearRect","totalBars","min","frequencyStep","i","index","pow","value","barHeight","max","x","y","colorPercent","barColor","fillStyle","fillRect","drawWaveform","waveform","lineWidth","color","filled","mirror","strokeStyle","centerY","step","ceil","beginPath","moveTo","lineTo","fill","stroke","drawCircularSpectrum","radius","rotation","centerX","maxBars","barLength","angle","PI","x1","cos","y1","sin","x2","y2","createParticles","count","minSize","maxSize","maxSpeed","baseLife","particles","random","size","push","speed","life","opacity","updateParticles","volume","map","particle","adjustedSpeed","newX","newY","drawParticles","forEach","sizeMultiplier","globalAlpha","arc","waterfallHistory","drawAudioWaterfall","frequencyBins","row","Array","currentFrame","unshift","pop","binWidth","rowIndex","binIndex","drawKaleidoscope","segments","save","translate","rotate","basePattern","s","restore","drawOrganicForm","complexity","baseRadius","avgAmplitude","freqIndex","waveIndex","frequency","wave","variation","closePath","gradient","createRadialGradient","addColorStop","TETRIS_SHAPES","tetrisGrid","activeBlocks","tetrisLastUpdate","initTetrisGrid","cols","rows","createTetrisBlock","type","drawTetris","cellSize","gridWidth","gridHeight","offsetX","offsetY","now","Date","avgFreq","from","reduce","sum","val","normalizedFreq","updateInterval","block","shape","hitBottom","gridY","gridX","filter","every","cell","splice","strokeRect","cellX","cellY","mouthRadius","eyeState","blinkCounter","drawLipSync","faceColor","lipColor","faceSize","avgVolume","bassIntensity","ellipse","tongueHeight","abs","eyeX1","eyeX2","eyeY","eyeSize","eyeMoveX","eyeMoveY","browRaise","noteSize","noteX","noteY","meteors","lastMeteorTime","createMeteor","canvasWidth","canvasHeight","trail","drawMusicMeteorShower","density","background","energy","bassEnergy","meteor","shift","createLinearGradient","point","sparkX","sparkY","intensity","starSize","glowSize","glow","auroras","auroraY","auroraHeight","curvePoints","j","px","frequencyIndex","waveValue","py","current","next","midX","midY","quadraticCurveTo","flowers","leaves","lastFlowerTime","gardenBackground","createFlower","flowerBedWidth","groundY","stemLength","petals","stemWidth","growthStage","maxGrowth","bloomSpeed","swayAngle","swaySpeed","createLeaf","flowerX","yPos","drawSoundGarden","flowerDensity","leafColor","createImageData","data","skyRatio","putImageData","newFlower","leafCount","grassHeight","sort","a","flower","highFreqEnergy","stemEndX","stemEndY","cp1x","cp1y","bezierCurveTo","scaleFactor","scale","petalAngle","petalSize","leaf","butterflyCount","timeOffset","xPos","wingSize","wingAngle","sunX","sunY","sunRadius","sunGradient","beamCount","endX","endY","beamGradient","dnaNodes","dnaRotation","initDNA","pairStartColor","pairEndColor","isBase","zPos","colorPos","baseColor","pairColor","z","drawDNAHelix","rotationSpeed","perspective","camZ","helix","pitch","sortedNodes","connectionPairs","waveformEnergy","node","pairIndex","hasPair","spiralRadius","phaseOffset","freqValue","waveOffset","x2d","y2d","nodeSize","node1","node2","firstNode","pair","scale1","scale2","pairFreq","freq","pixelSize","beamX","beamY","ripples","dataParticles","lastRippleTime","createRipple","posX","posY","maxRadius","thickness","createDataParticle","chars","char","charAt","velocity","drawDigitalRipple","particleCount","rippleThreshold","newParticleCount","burstCount","ripple","segmentAngle","startAngle","endAngle","radiusVariation","dx","dy","distance","sqrt","rippleEdgeDistance","atan2","force","font","fillText","flashCount","flashX","flashY","codeRainCount","columnHeight","charSize","charOpacity","textParticles","particleText","textSize","textInitialized","initTextParticles","text","textAlign","tempCanvas","document","createElement","tempCtx","getContext","textBaseline","imageData","getImageData","sampleStep","originX","originY","vx","vy","alpha","brightness","drawParticleText","particleSize","customTextSize","easeDistance","interactive","highEnergy","mouseX","mouseY","waveX","waveY","frequencyValue","targetX","targetY","mouseForceRadius","otherParticle","VisualizationType"],"sources":["C:/Users/20213/Desktop/web/src/utils/visualEffects.ts"],"sourcesContent":["// 定义常用的可视化效果\n\n// 颜色工具\nexport const getGradientColor = (\n  startColor: string,\n  endColor: string, \n  percent: number\n): string => {\n  // 解析颜色\n  const start = {\n    r: parseInt(startColor.slice(1, 3), 16),\n    g: parseInt(startColor.slice(3, 5), 16),\n    b: parseInt(startColor.slice(5, 7), 16)\n  };\n  \n  const end = {\n    r: parseInt(endColor.slice(1, 3), 16),\n    g: parseInt(endColor.slice(3, 5), 16),\n    b: parseInt(endColor.slice(5, 7), 16)\n  };\n  \n  // 计算渐变颜色\n  const r = Math.floor(start.r + percent * (end.r - start.r));\n  const g = Math.floor(start.g + percent * (end.g - start.g));\n  const b = Math.floor(start.b + percent * (end.b - start.b));\n  \n  // 转换为十六进制\n  return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n};\n\n// 频谱柱状图\nexport const drawSpectrumBars = (\n  ctx: CanvasRenderingContext2D,\n  frequencies: Uint8Array,\n  width: number,\n  height: number,\n  options: {\n    barWidth?: number;\n    barSpacing?: number;\n    startColor?: string;\n    endColor?: string;\n    minHeight?: number;\n    maxFreq?: number;\n  } = {}\n) => {\n  const {\n    barWidth = 5,\n    barSpacing = 2,\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    minHeight = 5,\n    maxFreq = frequencies.length * 0.75 // 只显示频率范围的75%，高频部分通常人耳听不到\n  } = options;\n  \n  ctx.clearRect(0, 0, width, height);\n  \n  const totalBars = Math.min(Math.floor(width / (barWidth + barSpacing)), maxFreq);\n  const frequencyStep = Math.floor(frequencies.length / totalBars);\n  \n  for (let i = 0; i < totalBars; i++) {\n    // 使用对数分布使低频更加清晰\n    const index = Math.floor(Math.pow(i / totalBars, 2) * maxFreq);\n    const value = frequencies[index] / 255; // 归一化到0-1\n    \n    const barHeight = Math.max(minHeight, value * height);\n    const x = i * (barWidth + barSpacing);\n    const y = height - barHeight;\n    \n    // 根据频率和音量生成颜色\n    const colorPercent = value;\n    const barColor = getGradientColor(startColor, endColor, colorPercent);\n    \n    ctx.fillStyle = barColor;\n    ctx.fillRect(x, y, barWidth, barHeight);\n  }\n};\n\n// 波形图\nexport const drawWaveform = (\n  ctx: CanvasRenderingContext2D,\n  waveform: Float32Array,\n  width: number,\n  height: number,\n  options: {\n    lineWidth?: number;\n    color?: string;\n    filled?: boolean;\n    mirror?: boolean;\n  } = {}\n) => {\n  const {\n    lineWidth = 2,\n    color = '#ba68c8',\n    filled = false,\n    mirror = false\n  } = options;\n  \n  ctx.clearRect(0, 0, width, height);\n  ctx.lineWidth = lineWidth;\n  ctx.strokeStyle = color;\n  ctx.fillStyle = color;\n  \n  const centerY = height / 2;\n  const step = Math.ceil(waveform.length / width);\n  \n  ctx.beginPath();\n  \n  if (filled) {\n    ctx.moveTo(0, centerY);\n  }\n  \n  for (let i = 0; i < width; i++) {\n    const index = Math.floor(i * step);\n    const value = waveform[index];\n    \n    // 计算y坐标，波形值范围是-1到1\n    const y = mirror\n      ? centerY + value * centerY // 将波形映射到整个高度\n      : centerY + value * (centerY * 0.8); // 留出一些边距\n      \n    if (i === 0) {\n      ctx.moveTo(i, y);\n    } else {\n      ctx.lineTo(i, y);\n    }\n  }\n  \n  if (filled) {\n    ctx.lineTo(width, centerY);\n    ctx.fill();\n  } else {\n    ctx.stroke();\n  }\n};\n\n// 圆形频谱\nexport const drawCircularSpectrum = (\n  ctx: CanvasRenderingContext2D,\n  frequencies: Uint8Array,\n  width: number,\n  height: number,\n  options: {\n    radius?: number;\n    startColor?: string;\n    endColor?: string;\n    lineWidth?: number;\n    rotation?: number;\n  } = {}\n) => {\n  const {\n    radius = Math.min(width, height) / 3,\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    lineWidth = 2,\n    rotation = 0\n  } = options;\n  \n  ctx.clearRect(0, 0, width, height);\n  \n  const centerX = width / 2;\n  const centerY = height / 2;\n  const maxBars = 180; // 圆周上的点数\n  const step = Math.ceil(frequencies.length / maxBars);\n  \n  for (let i = 0; i < maxBars; i++) {\n    const index = Math.floor(i * step);\n    const value = frequencies[index] / 255; // 归一化到0-1\n    \n    const barLength = radius * (0.5 + value * 0.5); // 长度在半径的50%-100%之间变化\n    const angle = (i / maxBars) * Math.PI * 2 + rotation;\n    \n    const x1 = centerX + Math.cos(angle) * radius;\n    const y1 = centerY + Math.sin(angle) * radius;\n    \n    const x2 = centerX + Math.cos(angle) * (radius + barLength);\n    const y2 = centerY + Math.sin(angle) * (radius + barLength);\n    \n    const color = getGradientColor(startColor, endColor, value);\n    \n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = color;\n    \n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n  }\n};\n\n// 粒子系统\nexport interface Particle {\n  x: number;\n  y: number;\n  size: number;\n  color: string;\n  speed: number;\n  angle: number;\n  life: number;\n  opacity: number;\n}\n\nexport const createParticles = (\n  count: number,\n  width: number,\n  height: number,\n  options: {\n    minSize?: number;\n    maxSize?: number;\n    startColor?: string;\n    endColor?: string;\n    maxSpeed?: number;\n    baseLife?: number;\n  } = {}\n): Particle[] => {\n  const {\n    minSize = 2,\n    maxSize = 8,\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    maxSpeed = 2,\n    baseLife = 100\n  } = options;\n  \n  const particles: Particle[] = [];\n  \n  for (let i = 0; i < count; i++) {\n    const percent = Math.random();\n    const size = minSize + Math.random() * (maxSize - minSize);\n    \n    particles.push({\n      x: Math.random() * width,\n      y: Math.random() * height,\n      size,\n      color: getGradientColor(startColor, endColor, percent),\n      speed: Math.random() * maxSpeed,\n      angle: Math.random() * Math.PI * 2,\n      life: baseLife + Math.random() * baseLife,\n      opacity: 0.7 + Math.random() * 0.3\n    });\n  }\n  \n  return particles;\n};\n\nexport const updateParticles = (\n  particles: Particle[],\n  width: number,\n  height: number,\n  volume: number\n): Particle[] => {\n  return particles.map(particle => {\n    // 根据音量调整速度\n    const adjustedSpeed = particle.speed * (1 + volume * 3);\n    \n    // 更新位置\n    const newX = particle.x + Math.cos(particle.angle) * adjustedSpeed;\n    const newY = particle.y + Math.sin(particle.angle) * adjustedSpeed;\n    \n    // 如果粒子离开画布，将其重置到另一边\n    const x = newX < 0 ? width : newX > width ? 0 : newX;\n    const y = newY < 0 ? height : newY > height ? 0 : newY;\n    \n    // 递减生命值\n    const life = particle.life - 1;\n    \n    // 如果生命值用完，重新创建粒子\n    if (life <= 0) {\n      return {\n        x: Math.random() * width,\n        y: Math.random() * height,\n        size: particle.size,\n        color: particle.color,\n        speed: particle.speed,\n        angle: Math.random() * Math.PI * 2,\n        life: 100 + Math.random() * 100,\n        opacity: 0.7 + Math.random() * 0.3\n      };\n    }\n    \n    return {\n      ...particle,\n      x,\n      y,\n      life\n    };\n  });\n};\n\nexport const drawParticles = (\n  ctx: CanvasRenderingContext2D,\n  particles: Particle[],\n  volume: number\n) => {\n  particles.forEach(particle => {\n    // 根据音量和生命值调整大小和不透明度\n    const sizeMultiplier = 1 + volume * 2;\n    const size = particle.size * sizeMultiplier;\n    const opacity = (particle.opacity * particle.life) / 200;\n    \n    ctx.globalAlpha = opacity;\n    ctx.fillStyle = particle.color;\n    \n    ctx.beginPath();\n    ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);\n    ctx.fill();\n  });\n  \n  ctx.globalAlpha = 1;\n};\n\n// 存储音频瀑布图的历史数据\nlet waterfallHistory: number[][] = [];\n\n// 音频瀑布图\nexport const drawAudioWaterfall = (\n  ctx: CanvasRenderingContext2D,\n  frequencies: Uint8Array,\n  width: number,\n  height: number,\n  options: {\n    startColor?: string;\n    endColor?: string;\n    speed?: number;\n  } = {}\n) => {\n  const {\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    speed = 2\n  } = options;\n  \n  const frequencyBins = 64; // 采样的频率点数\n  const step = Math.floor(frequencies.length / frequencyBins);\n  \n  // 如果历史数据为空，初始化\n  if (waterfallHistory.length === 0) {\n    for (let i = 0; i < Math.floor(height / speed); i++) {\n      const row = Array(frequencyBins).fill(0);\n      waterfallHistory.push(row);\n    }\n  }\n  \n  // 获取当前帧的频率数据\n  const currentFrame = [];\n  for (let i = 0; i < frequencyBins; i++) {\n    const index = Math.floor(i * step);\n    currentFrame.push(frequencies[index] / 255); // 归一化到0-1\n  }\n  \n  // 更新历史数据\n  waterfallHistory.unshift(currentFrame);\n  if (waterfallHistory.length > Math.floor(height / speed)) {\n    waterfallHistory.pop();\n  }\n  \n  // 清除画布\n  ctx.clearRect(0, 0, width, height);\n  \n  // 绘制瀑布图\n  const binWidth = width / frequencyBins;\n  \n  waterfallHistory.forEach((row, rowIndex) => {\n    const y = rowIndex * speed;\n    \n    row.forEach((value, binIndex) => {\n      const x = binIndex * binWidth;\n      const color = getGradientColor(startColor, endColor, value);\n      \n      ctx.fillStyle = color;\n      ctx.globalAlpha = 0.8;\n      ctx.fillRect(x, y, binWidth, speed);\n    });\n  });\n  \n  ctx.globalAlpha = 1;\n};\n\n// 万花筒效果\nexport const drawKaleidoscope = (\n  ctx: CanvasRenderingContext2D,\n  frequencies: Uint8Array,\n  width: number,\n  height: number,\n  options: {\n    startColor?: string;\n    endColor?: string;\n    segments?: number;\n    rotation?: number;\n  } = {}\n) => {\n  const {\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    segments = 8,\n    rotation = 0\n  } = options;\n  \n  // 清除画布\n  ctx.clearRect(0, 0, width, height);\n  \n  const centerX = width / 2;\n  const centerY = height / 2;\n  const radius = Math.min(centerX, centerY) * 0.8;\n  \n  // 保存当前状态\n  ctx.save();\n  ctx.translate(centerX, centerY);\n  ctx.rotate(rotation);\n  \n  // 创建一个基本图形\n  const basePattern = (ctx: CanvasRenderingContext2D) => {\n    const frequencyBins = 32;\n    const step = Math.floor(frequencies.length / frequencyBins);\n    \n    for (let i = 0; i < frequencyBins; i++) {\n      const index = Math.floor(i * step);\n      const value = frequencies[index] / 255; // 归一化到0-1\n      \n      const angle = (i / frequencyBins) * Math.PI * 2 / segments;\n      const length = radius * value;\n      \n      const x = Math.cos(angle) * length;\n      const y = Math.sin(angle) * length;\n      \n      const color = getGradientColor(startColor, endColor, value);\n      \n      ctx.fillStyle = color;\n      ctx.beginPath();\n      ctx.arc(x, y, 5 + value * 15, 0, Math.PI * 2);\n      ctx.fill();\n      \n      // 连接到中心的线\n      ctx.strokeStyle = color;\n      ctx.lineWidth = 2;\n      ctx.globalAlpha = 0.5;\n      ctx.beginPath();\n      ctx.moveTo(0, 0);\n      ctx.lineTo(x, y);\n      ctx.stroke();\n      ctx.globalAlpha = 1;\n    }\n  };\n  \n  // 绘制多个反射的图形\n  for (let s = 0; s < segments; s++) {\n    ctx.save();\n    ctx.rotate((s / segments) * Math.PI * 2);\n    basePattern(ctx);\n    ctx.restore();\n  }\n  \n  // 恢复状态\n  ctx.restore();\n};\n\n// 有机形态\nexport const drawOrganicForm = (\n  ctx: CanvasRenderingContext2D,\n  frequencies: Uint8Array,\n  waveform: Float32Array,\n  width: number,\n  height: number,\n  options: {\n    startColor?: string;\n    endColor?: string;\n    complexity?: number;\n  } = {}\n) => {\n  const {\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    complexity = 0.7\n  } = options;\n  \n  // 清除画布\n  ctx.clearRect(0, 0, width, height);\n  \n  const centerX = width / 2;\n  const centerY = height / 2;\n  const baseRadius = Math.min(centerX, centerY) * 0.6;\n  \n  const frequencyBins = 32;\n  const step = Math.floor(frequencies.length / frequencyBins);\n  \n  // 计算平均振幅\n  let avgAmplitude = 0;\n  for (let i = 0; i < frequencies.length; i++) {\n    avgAmplitude += frequencies[i] / 255;\n  }\n  avgAmplitude /= frequencies.length;\n  \n  // 绘制有机形态\n  ctx.beginPath();\n  \n  for (let i = 0; i <= frequencyBins; i++) {\n    const angle = (i / frequencyBins) * Math.PI * 2;\n    \n    // 使用频率数据和波形数据创建有机的变形效果\n    const freqIndex = Math.floor(i * step) % frequencies.length;\n    const waveIndex = Math.floor(i * waveform.length / frequencyBins) % waveform.length;\n    \n    const frequency = frequencies[freqIndex] / 255;\n    const wave = (waveform[waveIndex] + 1) / 2; // 转换到0-1范围\n    \n    // 结合频率和波形数据\n    const variation = frequency * wave * complexity;\n    const radius = baseRadius * (0.7 + variation * 0.5);\n    \n    const x = centerX + Math.cos(angle) * radius;\n    const y = centerY + Math.sin(angle) * radius;\n    \n    if (i === 0) {\n      ctx.moveTo(x, y);\n    } else {\n      ctx.lineTo(x, y);\n    }\n  }\n  \n  ctx.closePath();\n  \n  // 创建渐变填充\n  const gradient = ctx.createRadialGradient(\n    centerX, centerY, 0,\n    centerX, centerY, baseRadius\n  );\n  gradient.addColorStop(0, startColor);\n  gradient.addColorStop(1, endColor);\n  \n  // 填充和描边\n  ctx.fillStyle = gradient;\n  ctx.fill();\n  \n  ctx.strokeStyle = getGradientColor(startColor, endColor, avgAmplitude);\n  ctx.lineWidth = 2;\n  ctx.stroke();\n};\n\n// 俄罗斯方块效果\ninterface TetrisBlock {\n  x: number;\n  y: number;\n  type: number;\n  rotation: number;\n  color: string;\n}\n\n// 俄罗斯方块块类型形状\nconst TETRIS_SHAPES = [\n  // I形\n  [\n    [0, 0, 0, 0],\n    [1, 1, 1, 1],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0]\n  ],\n  // J形\n  [\n    [1, 0, 0],\n    [1, 1, 1],\n    [0, 0, 0]\n  ],\n  // L形\n  [\n    [0, 0, 1],\n    [1, 1, 1],\n    [0, 0, 0]\n  ],\n  // O形\n  [\n    [1, 1],\n    [1, 1]\n  ],\n  // S形\n  [\n    [0, 1, 1],\n    [1, 1, 0],\n    [0, 0, 0]\n  ],\n  // T形\n  [\n    [0, 1, 0],\n    [1, 1, 1],\n    [0, 0, 0]\n  ],\n  // Z形\n  [\n    [1, 1, 0],\n    [0, 1, 1],\n    [0, 0, 0]\n  ]\n];\n\n// 存储当前的方块和网格\nlet tetrisGrid: number[][] = [];\nlet activeBlocks: TetrisBlock[] = [];\nlet tetrisLastUpdate = 0;\n\n// 初始化俄罗斯方块网格\nconst initTetrisGrid = (cols: number, rows: number) => {\n  tetrisGrid = [];\n  for (let i = 0; i < rows; i++) {\n    tetrisGrid.push(Array(cols).fill(0));\n  }\n};\n\n// 创建新的方块\nconst createTetrisBlock = (cols: number, startColor: string, endColor: string): TetrisBlock => {\n  const type = Math.floor(Math.random() * TETRIS_SHAPES.length);\n  const color = getGradientColor(startColor, endColor, Math.random());\n  \n  return {\n    x: Math.floor(cols / 2) - Math.floor(TETRIS_SHAPES[type][0].length / 2),\n    y: 0,\n    type,\n    rotation: 0,\n    color\n  };\n};\n\n// 绘制俄罗斯方块效果\nexport const drawTetris = (\n  ctx: CanvasRenderingContext2D,\n  frequencies: Uint8Array,\n  width: number,\n  height: number,\n  options: {\n    startColor?: string;\n    endColor?: string;\n    speed?: number;\n  } = {}\n) => {\n  const {\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    speed = 1\n  } = options;\n  \n  // 计算网格尺寸\n  const cols = 12;\n  const rows = 20;\n  const cellSize = Math.min(width / cols, height / rows);\n  const gridWidth = cols * cellSize;\n  const gridHeight = rows * cellSize;\n  const offsetX = (width - gridWidth) / 2;\n  const offsetY = (height - gridHeight) / 2;\n  \n  // 初始化网格\n  if (tetrisGrid.length === 0) {\n    initTetrisGrid(cols, rows);\n  }\n  \n  // 根据音频数据控制游戏速度\n  const now = Date.now();\n  const avgFreq = Array.from(frequencies).reduce((sum, val) => sum + val, 0) / frequencies.length;\n  const normalizedFreq = avgFreq / 255;\n  \n  // 音量越大，方块下落越快\n  const updateInterval = 1000 - normalizedFreq * 800;\n  \n  // 音量脉冲添加新方块\n  if (normalizedFreq > 0.6 && Math.random() < 0.1) {\n    activeBlocks.push(createTetrisBlock(cols, startColor, endColor));\n  }\n  \n  // 更新方块位置\n  if (now - tetrisLastUpdate > updateInterval) {\n    tetrisLastUpdate = now;\n    \n    // 创建初始方块\n    if (activeBlocks.length === 0) {\n      activeBlocks.push(createTetrisBlock(cols, startColor, endColor));\n    }\n    \n    // 尝试移动活动方块\n    activeBlocks.forEach(block => {\n      block.y += 1;\n      \n      // 如果方块触底或碰到其他方块，固定它并创建新方块\n      const shape = TETRIS_SHAPES[block.type];\n      let hitBottom = false;\n      \n      // 检查是否触底\n      for (let y = 0; y < shape.length; y++) {\n        for (let x = 0; x < shape[y].length; x++) {\n          if (shape[y][x] === 0) continue;\n          \n          const gridY = block.y + y;\n          const gridX = block.x + x;\n          \n          // 检查是否到达底部或碰到其他方块\n          if (gridY >= rows || (gridY >= 0 && tetrisGrid[gridY][gridX] !== 0)) {\n            hitBottom = true;\n            break;\n          }\n        }\n        if (hitBottom) break;\n      }\n      \n      // 如果触底，将方块固定到网格\n      if (hitBottom) {\n        // 回退一步\n        block.y -= 1;\n        \n        // 将方块添加到网格\n        for (let y = 0; y < shape.length; y++) {\n          for (let x = 0; x < shape[y].length; x++) {\n            if (shape[y][x] === 0) continue;\n            \n            const gridY = block.y + y;\n            const gridX = block.x + x;\n            \n            if (gridY >= 0 && gridY < rows && gridX >= 0 && gridX < cols) {\n              tetrisGrid[gridY][gridX] = 1;\n            }\n          }\n        }\n      }\n    });\n    \n    // 删除已固定的方块\n    activeBlocks = activeBlocks.filter(block => {\n      const shape = TETRIS_SHAPES[block.type];\n      for (let y = 0; y < shape.length; y++) {\n        for (let x = 0; x < shape[y].length; x++) {\n          if (shape[y][x] === 0) continue;\n          \n          const gridY = block.y + y;\n          const gridX = block.x + x;\n          \n          // 如果方块已经添加到网格中，则删除它\n          if (gridY >= 0 && gridY < rows && gridX >= 0 && gridX < cols && tetrisGrid[gridY][gridX] === 1) {\n            return false;\n          }\n        }\n      }\n      return true;\n    });\n    \n    // 清除完整的行\n    for (let y = rows - 1; y >= 0; y--) {\n      if (tetrisGrid[y].every(cell => cell === 1)) {\n        // 移除该行\n        tetrisGrid.splice(y, 1);\n        // 在顶部添加新行\n        tetrisGrid.unshift(Array(cols).fill(0));\n      }\n    }\n    \n    // 根据音量随机添加新方块\n    if (Math.random() < 0.1 * normalizedFreq) {\n      activeBlocks.push(createTetrisBlock(cols, startColor, endColor));\n    }\n  }\n  \n  // 清除画布\n  ctx.clearRect(0, 0, width, height);\n  \n  // 绘制网格背景\n  ctx.fillStyle = '#111';\n  ctx.fillRect(offsetX, offsetY, gridWidth, gridHeight);\n  \n  // 绘制边框\n  ctx.strokeStyle = '#333';\n  ctx.lineWidth = 2;\n  ctx.strokeRect(offsetX, offsetY, gridWidth, gridHeight);\n  \n  // 绘制固定方块\n  for (let y = 0; y < rows; y++) {\n    for (let x = 0; x < cols; x++) {\n      if (tetrisGrid[y][x] === 1) {\n        const cellX = offsetX + x * cellSize;\n        const cellY = offsetY + y * cellSize;\n        \n        // 根据频率选择颜色\n        const freqIndex = (x + y) % frequencies.length;\n        const colorPercent = frequencies[freqIndex] / 255;\n        const color = getGradientColor(startColor, endColor, colorPercent);\n        \n        ctx.fillStyle = color;\n        ctx.fillRect(cellX, cellY, cellSize - 1, cellSize - 1);\n      }\n    }\n  }\n  \n  // 绘制活动方块\n  activeBlocks.forEach(block => {\n    const shape = TETRIS_SHAPES[block.type];\n    \n    for (let y = 0; y < shape.length; y++) {\n      for (let x = 0; x < shape[y].length; x++) {\n        if (shape[y][x] === 0) continue;\n        \n        const cellX = offsetX + (block.x + x) * cellSize;\n        const cellY = offsetY + (block.y + y) * cellSize;\n        \n        if (\n          cellX >= offsetX && \n          cellX < offsetX + gridWidth && \n          cellY >= offsetY && \n          cellY < offsetY + gridHeight\n        ) {\n          ctx.fillStyle = block.color;\n          ctx.fillRect(cellX, cellY, cellSize - 1, cellSize - 1);\n        }\n      }\n    }\n  });\n};\n\n// 卡通嘴型同步\n// 存储嘴型状态\nlet mouthRadius = 0;\nlet eyeState = 0;\nlet blinkCounter = 0;\n\n// 绘制卡通人物嘴型同步效果\nexport const drawLipSync = (\n  ctx: CanvasRenderingContext2D,\n  frequencies: Uint8Array,\n  waveform: Float32Array,\n  width: number,\n  height: number,\n  options: {\n    faceColor?: string;\n    lipColor?: string;\n  } = {}\n) => {\n  const {\n    faceColor = '#ffcc99',\n    lipColor = '#ff6666'\n  } = options;\n  \n  // 清除画布\n  ctx.clearRect(0, 0, width, height);\n  \n  const centerX = width / 2;\n  const centerY = height / 2;\n  const faceSize = Math.min(width, height) * 0.6;\n  \n  // 计算平均音量和低频强度\n  let avgVolume = 0;\n  let bassIntensity = 0;\n  \n  // 获取低频能量（嘴巴张开程度）\n  for (let i = 0; i < 10; i++) {\n    bassIntensity += frequencies[i] / 255;\n  }\n  bassIntensity /= 10;\n  \n  // 获取总体音量（表情活跃度）\n  for (let i = 0; i < frequencies.length; i++) {\n    avgVolume += frequencies[i] / 255;\n  }\n  avgVolume /= frequencies.length;\n  \n  // 平滑嘴型变化\n  mouthRadius = mouthRadius * 0.7 + bassIntensity * 0.3 * faceSize * 0.3;\n  \n  // 眨眼控制\n  blinkCounter++;\n  if (blinkCounter > 120 || (avgVolume > 0.7 && Math.random() > 0.7)) {\n    eyeState = (eyeState + 1) % 3;\n    if (eyeState === 0) {\n      blinkCounter = 0;\n    }\n  }\n  \n  // 绘制脸部\n  ctx.fillStyle = faceColor;\n  ctx.beginPath();\n  ctx.arc(centerX, centerY, faceSize / 2, 0, Math.PI * 2);\n  ctx.fill();\n  \n  // 绘制嘴巴\n  ctx.fillStyle = lipColor;\n  ctx.beginPath();\n  ctx.ellipse(\n    centerX, \n    centerY + faceSize * 0.15, \n    mouthRadius * 1.5, \n    mouthRadius, \n    0, \n    0, \n    Math.PI * 2\n  );\n  ctx.fill();\n  \n  // 绘制嘴内（黑色）\n  ctx.fillStyle = '#000';\n  ctx.beginPath();\n  ctx.ellipse(\n    centerX, \n    centerY + faceSize * 0.15, \n    mouthRadius * 1.2, \n    mouthRadius * 0.7, \n    0, \n    0, \n    Math.PI * 2\n  );\n  ctx.fill();\n  \n  // 根据波形绘制舌头\n  let tongueHeight = 0;\n  for (let i = 0; i < waveform.length; i += 10) {\n    tongueHeight += Math.abs(waveform[i]);\n  }\n  tongueHeight = tongueHeight / (waveform.length / 10) * mouthRadius * 0.8;\n  \n  if (tongueHeight > 0.01) {\n    ctx.fillStyle = '#ff9999';\n    ctx.beginPath();\n    ctx.ellipse(\n      centerX, \n      centerY + faceSize * 0.15 + mouthRadius * 0.2, \n      mouthRadius * 0.8, \n      tongueHeight, \n      0, \n      0, \n      Math.PI\n    );\n    ctx.fill();\n  }\n  \n  // 绘制眼睛\n  const eyeX1 = centerX - faceSize * 0.15;\n  const eyeX2 = centerX + faceSize * 0.15;\n  const eyeY = centerY - faceSize * 0.1;\n  const eyeSize = faceSize * 0.1;\n  \n  // 眼白\n  ctx.fillStyle = '#ffffff';\n  ctx.beginPath();\n  ctx.arc(eyeX1, eyeY, eyeSize, 0, Math.PI * 2);\n  ctx.fill();\n  \n  ctx.beginPath();\n  ctx.arc(eyeX2, eyeY, eyeSize, 0, Math.PI * 2);\n  ctx.fill();\n  \n  // 眼珠（根据音频移动）\n  const eyeMoveX = (frequencies[15] / 255 - 0.5) * eyeSize * 0.5;\n  const eyeMoveY = (frequencies[20] / 255 - 0.5) * eyeSize * 0.5;\n  \n  if (eyeState === 0) {\n    // 正常眼睛\n    ctx.fillStyle = '#000000';\n    ctx.beginPath();\n    ctx.arc(eyeX1 + eyeMoveX, eyeY + eyeMoveY, eyeSize * 0.4, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.beginPath();\n    ctx.arc(eyeX2 + eyeMoveX, eyeY + eyeMoveY, eyeSize * 0.4, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // 眼神反光\n    ctx.fillStyle = '#ffffff';\n    ctx.beginPath();\n    ctx.arc(eyeX1 + eyeMoveX + eyeSize * 0.1, eyeY + eyeMoveY - eyeSize * 0.1, eyeSize * 0.1, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.beginPath();\n    ctx.arc(eyeX2 + eyeMoveX + eyeSize * 0.1, eyeY + eyeMoveY - eyeSize * 0.1, eyeSize * 0.1, 0, Math.PI * 2);\n    ctx.fill();\n  } else if (eyeState === 1) {\n    // 半闭眼\n    ctx.fillStyle = '#000000';\n    ctx.beginPath();\n    ctx.ellipse(eyeX1, eyeY, eyeSize * 0.4, eyeSize * 0.1, 0, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.beginPath();\n    ctx.ellipse(eyeX2, eyeY, eyeSize * 0.4, eyeSize * 0.1, 0, 0, Math.PI * 2);\n    ctx.fill();\n  } else {\n    // 闭眼\n    ctx.strokeStyle = '#000000';\n    ctx.lineWidth = 2;\n    \n    ctx.beginPath();\n    ctx.moveTo(eyeX1 - eyeSize * 0.5, eyeY);\n    ctx.lineTo(eyeX1 + eyeSize * 0.5, eyeY);\n    ctx.stroke();\n    \n    ctx.beginPath();\n    ctx.moveTo(eyeX2 - eyeSize * 0.5, eyeY);\n    ctx.lineTo(eyeX2 + eyeSize * 0.5, eyeY);\n    ctx.stroke();\n  }\n  \n  // 绘制眉毛（随着高频变化）\n  const browRaise = Math.max(0, frequencies[30] / 255 - 0.5) * faceSize * 0.1;\n  \n  ctx.strokeStyle = '#000000';\n  ctx.lineWidth = 3;\n  \n  // 左眉毛\n  ctx.beginPath();\n  ctx.moveTo(eyeX1 - eyeSize * 1.2, eyeY - eyeSize * 1.2 - browRaise);\n  ctx.lineTo(eyeX1 + eyeSize * 0.8, eyeY - eyeSize - browRaise * 0.5);\n  ctx.stroke();\n  \n  // 右眉毛\n  ctx.beginPath();\n  ctx.moveTo(eyeX2 + eyeSize * 1.2, eyeY - eyeSize * 1.2 - browRaise);\n  ctx.lineTo(eyeX2 - eyeSize * 0.8, eyeY - eyeSize - browRaise * 0.5);\n  ctx.stroke();\n  \n  // 根据音量添加表情变化（脸红）\n  if (avgVolume > 0.6) {\n    ctx.fillStyle = 'rgba(255, 150, 150, 0.3)';\n    ctx.beginPath();\n    ctx.arc(centerX - faceSize * 0.25, centerY + faceSize * 0.05, faceSize * 0.12, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.beginPath();\n    ctx.arc(centerX + faceSize * 0.25, centerY + faceSize * 0.05, faceSize * 0.12, 0, Math.PI * 2);\n    ctx.fill();\n  }\n  \n  // 绘制音符（在强拍时）\n  if (avgVolume > 0.65 && Math.random() > 0.7) {\n    const noteSize = faceSize * 0.15;\n    const noteX = centerX + faceSize * 0.6 * (Math.random() * 2 - 1);\n    const noteY = centerY - faceSize * 0.7;\n    \n    ctx.fillStyle = '#9c27b0';\n    ctx.beginPath();\n    ctx.ellipse(noteX, noteY, noteSize * 0.6, noteSize * 0.4, Math.PI * 0.25, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.strokeStyle = '#9c27b0';\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.moveTo(noteX + noteSize * 0.5, noteY);\n    ctx.lineTo(noteX + noteSize * 0.5, noteY - noteSize * 1.2);\n    ctx.stroke();\n  }\n};\n\n// 音乐流星雨\ninterface Meteor {\n  x: number;\n  y: number;\n  length: number;\n  speed: number;\n  color: string;\n  width: number;\n  trail: {x: number, y: number}[];\n}\n\nlet meteors: Meteor[] = [];\nlet lastMeteorTime = 0;\n\n// 创建流星\nconst createMeteor = (canvasWidth: number, canvasHeight: number, startColor: string, endColor: string): Meteor => {\n  const x = Math.random() * canvasWidth;\n  const y = -50; // 从画布上方开始\n  const length = 20 + Math.random() * 80;\n  const speed = 3 + Math.random() * 7;\n  const color = getGradientColor(startColor, endColor, Math.random());\n  const width = 1 + Math.random() * 3;\n  \n  return {\n    x, \n    y,\n    length,\n    speed,\n    color,\n    width,\n    trail: []\n  };\n};\n\n// 音乐流星雨效果\nexport const drawMusicMeteorShower = (\n  ctx: CanvasRenderingContext2D,\n  frequencies: Uint8Array,\n  waveform: Float32Array,\n  width: number,\n  height: number,\n  options: {\n    startColor?: string;\n    endColor?: string;\n    density?: number;\n    background?: string;\n  } = {}\n) => {\n  const {\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    density = 1,\n    background = 'rgba(0, 0, 0, 0.05)'\n  } = options;\n  \n  // 计算音频能量\n  let energy = 0;\n  for (let i = 0; i < frequencies.length; i++) {\n    energy += frequencies[i] / 255;\n  }\n  energy /= frequencies.length;\n  \n  // 半透明背景，创造拖尾效果\n  ctx.fillStyle = background;\n  ctx.fillRect(0, 0, width, height);\n  \n  // 生成新的流星\n  const now = Date.now();\n  const bassEnergy = frequencies.slice(0, 10).reduce((sum, val) => sum + val / 255, 0) / 10;\n  \n  // 根据低频能量和密度控制流星生成频率\n  if (now - lastMeteorTime > 300 / (bassEnergy * 2 * density) && Math.random() < bassEnergy * density) {\n    meteors.push(createMeteor(width, height, startColor, endColor));\n    lastMeteorTime = now;\n  }\n  \n  // 更新和绘制流星\n  meteors = meteors.filter(meteor => {\n    // 更新位置\n    meteor.y += meteor.speed * (1 + energy * 2); // 音频能量加速\n    meteor.x += meteor.speed * 0.5; // 轻微向右移动\n    \n    // 存储轨迹点\n    meteor.trail.push({x: meteor.x, y: meteor.y});\n    if (meteor.trail.length > 10) {\n      meteor.trail.shift();\n    }\n    \n    // 绘制流星\n    ctx.beginPath();\n    \n    // 绘制主体\n    const gradient = ctx.createLinearGradient(\n      meteor.x, \n      meteor.y, \n      meteor.x, \n      meteor.y - meteor.length\n    );\n    gradient.addColorStop(0, meteor.color);\n    gradient.addColorStop(1, 'transparent');\n    \n    ctx.strokeStyle = gradient;\n    ctx.lineWidth = meteor.width;\n    ctx.moveTo(meteor.x, meteor.y);\n    ctx.lineTo(meteor.x - meteor.speed * 0.5, meteor.y - meteor.length);\n    ctx.stroke();\n    \n    // 绘制轨迹点\n    ctx.fillStyle = meteor.color;\n    for (let i = 0; i < meteor.trail.length; i++) {\n      const point = meteor.trail[i];\n      const size = (i / meteor.trail.length) * meteor.width * 0.8;\n      ctx.beginPath();\n      ctx.arc(point.x, point.y, size, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    \n    // 随机添加闪光点\n    if (Math.random() < 0.3) {\n      const sparkX = meteor.x + (Math.random() - 0.5) * 5;\n      const sparkY = meteor.y - Math.random() * meteor.length * 0.8;\n      \n      ctx.beginPath();\n      ctx.arc(sparkX, sparkY, Math.random() * 1.5, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    \n    // 如果流星超出画布底部，则删除\n    return meteor.y < height + 100;\n  });\n  \n  // 绘制星空背景\n  for (let i = 0; i < frequencies.length; i += 5) {\n    const x = (i / frequencies.length) * width;\n    const y = height * 0.5 + (waveform[i] || 0) * height * 0.3;\n    const intensity = frequencies[i] / 255;\n    \n    if (intensity > 0.2) {\n      const starSize = intensity * 2;\n      \n      ctx.fillStyle = `rgba(255, 255, 255, ${intensity * 0.7})`;\n      ctx.beginPath();\n      ctx.arc(x, y, starSize, 0, Math.PI * 2);\n      ctx.fill();\n      \n      // 星星光芒\n      if (intensity > 0.7) {\n        const glowSize = starSize * 3;\n        const glow = ctx.createRadialGradient(x, y, 0, x, y, glowSize);\n        glow.addColorStop(0, `rgba(255, 255, 255, ${intensity * 0.5})`);\n        glow.addColorStop(1, 'transparent');\n        \n        ctx.fillStyle = glow;\n        ctx.beginPath();\n        ctx.arc(x, y, glowSize, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n  }\n  \n  // 在高能量时绘制北极光效果\n  if (energy > 0.5) {\n    const auroras = Math.floor(3 + energy * 4);\n    \n    for (let i = 0; i < auroras; i++) {\n      const auroraY = height * (0.7 + Math.random() * 0.2);\n      const auroraHeight = height * 0.2 * energy;\n      \n      const curvePoints = [];\n      const segments = 20;\n      \n      for (let j = 0; j <= segments; j++) {\n        const px = (j / segments) * width;\n        // 使用音频数据波形控制高度\n        const frequencyIndex = Math.floor((j / segments) * waveform.length);\n        const waveValue = waveform[frequencyIndex] || 0;\n        \n        const py = auroraY - Math.abs(waveValue) * auroraHeight;\n        curvePoints.push({x: px, y: py});\n      }\n      \n      // 绘制平滑曲线\n      ctx.beginPath();\n      ctx.moveTo(curvePoints[0].x, curvePoints[0].y);\n      \n      for (let j = 0; j < curvePoints.length - 1; j++) {\n        const current = curvePoints[j];\n        const next = curvePoints[j + 1];\n        const midX = (current.x + next.x) / 2;\n        const midY = (current.y + next.y) / 2;\n        \n        ctx.quadraticCurveTo(current.x, current.y, midX, midY);\n      }\n      \n      // 创建渐变\n      const gradient = ctx.createLinearGradient(0, auroraY - auroraHeight, 0, auroraY);\n      gradient.addColorStop(0, 'transparent');\n      gradient.addColorStop(0.5, getGradientColor(startColor, endColor, i / auroras));\n      gradient.addColorStop(1, 'transparent');\n      \n      ctx.strokeStyle = gradient;\n      ctx.lineWidth = 2 + energy * 5;\n      ctx.globalAlpha = 0.7;\n      ctx.stroke();\n      ctx.globalAlpha = 1;\n    }\n  }\n};\n\n// 声音花园\ninterface Flower {\n  x: number;\n  y: number;\n  size: number;\n  rotation: number;\n  petals: number;\n  color: string;\n  stemLength: number;\n  stemWidth: number;\n  growthStage: number;\n  maxGrowth: number;\n  bloomSpeed: number;\n  swayAngle: number;\n  swaySpeed: number;\n}\n\ninterface Leaf {\n  x: number;\n  y: number;\n  size: number;\n  angle: number;\n  color: string;\n}\n\n// 花朵管理\nlet flowers: Flower[] = [];\nlet leaves: Leaf[] = [];\nlet lastFlowerTime = 0;\nlet gardenBackground: ImageData | null = null;\n\n// 创建花朵\nconst createFlower = (\n  width: number, \n  height: number, \n  startColor: string, \n  endColor: string\n): Flower => {\n  const flowerBedWidth = width * 0.8;\n  const x = width * 0.1 + Math.random() * flowerBedWidth;\n  const groundY = height * 0.85;\n  const stemLength = 50 + Math.random() * 150;\n  const y = groundY - stemLength;\n  \n  return {\n    x,\n    y,\n    size: 10 + Math.random() * 40,\n    rotation: Math.random() * Math.PI * 2,\n    petals: 5 + Math.floor(Math.random() * 7),\n    color: getGradientColor(startColor, endColor, Math.random()),\n    stemLength,\n    stemWidth: 1 + Math.random() * 3,\n    growthStage: 0, // 0-1表示生长程度\n    maxGrowth: 0.8 + Math.random() * 0.2, // 最大生长程度\n    bloomSpeed: 0.001 + Math.random() * 0.003,\n    swayAngle: 0,\n    swaySpeed: 0.01 + Math.random() * 0.03\n  };\n};\n\n// 创建叶子\nconst createLeaf = (\n  flowerX: number, \n  stemLength: number, \n  groundY: number, \n  color: string\n): Leaf => {\n  const yPos = groundY - Math.random() * stemLength * 0.7;\n  const angle = (Math.random() > 0.5 ? 1 : -1) * (Math.PI / 4 + Math.random() * Math.PI / 4);\n  \n  return {\n    x: flowerX,\n    y: yPos,\n    size: 10 + Math.random() * 15,\n    angle,\n    color: color\n  };\n};\n\n// 声音花园效果\nexport const drawSoundGarden = (\n  ctx: CanvasRenderingContext2D,\n  frequencies: Uint8Array,\n  waveform: Float32Array,\n  width: number,\n  height: number,\n  options: {\n    startColor?: string;\n    endColor?: string;\n    flowerDensity?: number;\n    leafColor?: string;\n  } = {}\n) => {\n  const {\n    startColor = '#FF1493', // 深粉色\n    endColor = '#9370DB',  // 中紫色\n    flowerDensity = 1,\n    leafColor = '#4CAF50' // 绿色\n  } = options;\n  \n  const groundY = height * 0.85;\n  \n  // 初始化背景缓存\n  if (!gardenBackground) {\n    gardenBackground = ctx.createImageData(width, height);\n    const data = gardenBackground.data;\n    \n    // 创建天空渐变\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const index = (y * width + x) * 4;\n        \n        // 地面\n        if (y > groundY) {\n          data[index] = 121;     // R\n          data[index + 1] = 85;  // G\n          data[index + 2] = 72;  // B\n          data[index + 3] = 255; // A\n        } \n        // 天空\n        else {\n          const skyRatio = y / groundY;\n          data[index] = Math.floor(135 * (1 - skyRatio) + 176 * skyRatio);     // R\n          data[index + 1] = Math.floor(206 * (1 - skyRatio) + 224 * skyRatio); // G\n          data[index + 2] = Math.floor(235 * (1 - skyRatio) + 230 * skyRatio); // B\n          data[index + 3] = 255; // A\n        }\n      }\n    }\n  }\n  \n  // 绘制背景\n  ctx.putImageData(gardenBackground, 0, 0);\n  \n  // 计算音频能量\n  let energy = 0;\n  for (let i = 0; i < frequencies.length; i++) {\n    energy += frequencies[i] / 255;\n  }\n  energy /= frequencies.length;\n  \n  // 获取低频能量（生长速度）\n  let bassEnergy = 0;\n  for (let i = 0; i < 10; i++) {\n    bassEnergy += frequencies[i] / 255;\n  }\n  bassEnergy /= 10;\n  \n  // 根据音频能量添加新花朵\n  const now = Date.now();\n  if (now - lastFlowerTime > 2000 / flowerDensity && \n      flowers.length < 20 * flowerDensity && \n      Math.random() < bassEnergy * flowerDensity * 0.3) {\n    const newFlower = createFlower(width, height, startColor, endColor);\n    flowers.push(newFlower);\n    \n    // 为花朵添加叶子\n    const leafCount = 1 + Math.floor(Math.random() * 3);\n    for (let i = 0; i < leafCount; i++) {\n      leaves.push(createLeaf(newFlower.x, newFlower.stemLength, groundY, leafColor));\n    }\n    \n    lastFlowerTime = now;\n  }\n  \n  // 绘制草地纹理\n  ctx.fillStyle = '#7CB342'; // 浅草绿\n  for (let x = 0; x < width; x += 4) {\n    const grassHeight = 5 + Math.sin(x * 0.1) * 3 + Math.random() * 5;\n    ctx.fillRect(x, groundY - grassHeight, 2, grassHeight);\n  }\n  \n  // 绘制随机小花\n  for (let i = 0; i < 30 * flowerDensity; i++) {\n    const x = Math.random() * width;\n    const y = groundY - Math.random() * 10;\n    const size = 1 + Math.random() * 2;\n    \n    ctx.fillStyle = getGradientColor(startColor, endColor, Math.random());\n    ctx.beginPath();\n    ctx.arc(x, y, size, 0, Math.PI * 2);\n    ctx.fill();\n  }\n  \n  // 按y坐标排序花朵，确保前面的花朵覆盖后面的花朵\n  flowers.sort((a, b) => (a.y + a.stemLength) - (b.y + b.stemLength));\n  \n  // 更新和绘制花朵\n  flowers = flowers.filter(flower => {\n    // 根据音频能量更新生长阶段\n    flower.growthStage = Math.min(\n      flower.maxGrowth, \n      flower.growthStage + flower.bloomSpeed * (1 + bassEnergy * 3)\n    );\n    \n    // 更新摇摆角度，基于高频部分\n    const highFreqEnergy = frequencies[30] / 255;\n    flower.swayAngle += flower.swaySpeed * Math.sin(Date.now() * 0.001) * (1 + highFreqEnergy);\n    flower.swayAngle *= 0.95; // 阻尼\n    \n    // 花茎随着音频摇摆\n    const stemEndX = flower.x + Math.sin(flower.swayAngle) * flower.stemLength * 0.2;\n    const stemEndY = flower.y;\n    \n    // 绘制花茎\n    ctx.strokeStyle = '#4CAF50';\n    ctx.lineWidth = flower.stemWidth;\n    ctx.beginPath();\n    ctx.moveTo(flower.x, groundY);\n    \n    // 曲线花茎\n    const cp1x = flower.x + Math.sin(flower.swayAngle * 0.5) * flower.stemLength * 0.1;\n    const cp1y = groundY - flower.stemLength * 0.5;\n    \n    ctx.bezierCurveTo(cp1x, cp1y, stemEndX, stemEndY + flower.stemLength * 0.3, stemEndX, stemEndY);\n    ctx.stroke();\n    \n    // 只绘制生长阶段的花朵\n    if (flower.growthStage > 0.1) {\n      // 保存上下文\n      ctx.save();\n      ctx.translate(stemEndX, stemEndY);\n      ctx.rotate(flower.rotation + flower.swayAngle * 0.2);\n      \n      const scaleFactor = flower.growthStage;\n      ctx.scale(scaleFactor, scaleFactor);\n      \n      // 花芯\n      ctx.fillStyle = '#FFC107'; // 黄色花蕊\n      ctx.beginPath();\n      ctx.arc(0, 0, flower.size * 0.2, 0, Math.PI * 2);\n      ctx.fill();\n      \n      // 花瓣\n      for (let i = 0; i < flower.petals; i++) {\n        const petalAngle = (i / flower.petals) * Math.PI * 2;\n        const petalSize = flower.size * (0.8 + Math.sin(Date.now() * 0.005 + i) * 0.05);\n        \n        ctx.fillStyle = flower.color;\n        ctx.beginPath();\n        \n        // 创建花瓣形状\n        ctx.ellipse(\n          Math.cos(petalAngle) * flower.size * 0.5,\n          Math.sin(petalAngle) * flower.size * 0.5,\n          petalSize * 0.25,\n          petalSize * 0.5,\n          petalAngle,\n          0,\n          Math.PI * 2\n        );\n        \n        ctx.fill();\n      }\n      \n      // 恢复上下文\n      ctx.restore();\n    }\n    \n    // 保持生长完成的花朵\n    return flower.growthStage < flower.maxGrowth || flower.growthStage >= flower.maxGrowth;\n  });\n  \n  // 更新和绘制叶子\n  leaves = leaves.filter(leaf => {\n    ctx.save();\n    ctx.translate(leaf.x, leaf.y);\n    ctx.rotate(leaf.angle + Math.sin(Date.now() * 0.002) * 0.1);\n    \n    // 绘制叶子形状\n    ctx.fillStyle = leaf.color;\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.bezierCurveTo(\n      leaf.size * 0.5, -leaf.size * 0.5,\n      leaf.size, -leaf.size * 0.2,\n      leaf.size * 1.5, 0\n    );\n    ctx.bezierCurveTo(\n      leaf.size, leaf.size * 0.2,\n      leaf.size * 0.5, leaf.size * 0.5,\n      0, 0\n    );\n    ctx.fill();\n    \n    // 叶脉\n    ctx.strokeStyle = 'rgba(0, 100, 0, 0.5)';\n    ctx.lineWidth = 0.5;\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(leaf.size, 0);\n    ctx.stroke();\n    \n    for (let i = 1; i <= 3; i++) {\n      const y = leaf.size * 0.25 * i / 3;\n      ctx.beginPath();\n      ctx.moveTo(0, 0);\n      ctx.quadraticCurveTo(leaf.size * 0.5, y, leaf.size * 0.7, y * 0.8);\n      ctx.stroke();\n      \n      ctx.beginPath();\n      ctx.moveTo(0, 0);\n      ctx.quadraticCurveTo(leaf.size * 0.5, -y, leaf.size * 0.7, -y * 0.8);\n      ctx.stroke();\n    }\n    \n    ctx.restore();\n    \n    // 保留所有叶子\n    return true;\n  });\n  \n  // 根据波形绘制蝴蝶\n  if (energy > 0.4) {\n    const butterflyCount = Math.floor(energy * 5);\n    \n    for (let i = 0; i < butterflyCount; i++) {\n      // 使用波形作为路径\n      const timeOffset = Date.now() * 0.001 + i * 10;\n      const xPos = (Math.sin(timeOffset * 0.2) * 0.5 + 0.5) * width;\n      const yPos = groundY * 0.5 + Math.sin(timeOffset * 0.3) * groundY * 0.3;\n      \n      const wingSize = 5 + Math.sin(timeOffset) * 5;\n      const wingAngle = Math.sin(timeOffset * 10) * 0.5;\n      \n      // 蝴蝶身体\n      ctx.fillStyle = '#000';\n      ctx.beginPath();\n      ctx.ellipse(xPos, yPos, 5, 2, 0, 0, Math.PI * 2);\n      ctx.fill();\n      \n      // 翅膀\n      ctx.fillStyle = getGradientColor(startColor, endColor, i / butterflyCount);\n      \n      // 左翅\n      ctx.save();\n      ctx.translate(xPos, yPos);\n      ctx.rotate(-Math.PI / 4 - wingAngle);\n      ctx.beginPath();\n      ctx.ellipse(0, -wingSize, wingSize, wingSize * 2, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n      \n      // 右翅\n      ctx.save();\n      ctx.translate(xPos, yPos);\n      ctx.rotate(Math.PI / 4 + wingAngle);\n      ctx.beginPath();\n      ctx.ellipse(0, -wingSize, wingSize, wingSize * 2, 0, 0, Math.PI * 2);\n      ctx.fill();\n      ctx.restore();\n    }\n  }\n  \n  // 如果音频能量高，添加阳光光束\n  if (energy > 0.6) {\n    const sunX = width * 0.8;\n    const sunY = height * 0.15;\n    const sunRadius = 40 * energy;\n    \n    // 太阳\n    const sunGradient = ctx.createRadialGradient(\n      sunX, sunY, 0,\n      sunX, sunY, sunRadius\n    );\n    sunGradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');\n    sunGradient.addColorStop(0.5, 'rgba(255, 165, 0, 0.6)');\n    sunGradient.addColorStop(1, 'rgba(255, 69, 0, 0)');\n    \n    ctx.fillStyle = sunGradient;\n    ctx.beginPath();\n    ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // 光束\n    const beamCount = Math.floor(5 + energy * 5);\n    \n    for (let i = 0; i < beamCount; i++) {\n      const angle = (i / beamCount) * Math.PI * 2 + Date.now() * 0.0005;\n      const length = width * 0.5 * (0.5 + energy * 0.5);\n      \n      const endX = sunX + Math.cos(angle) * length;\n      const endY = sunY + Math.sin(angle) * length;\n      \n      const beamGradient = ctx.createLinearGradient(sunX, sunY, endX, endY);\n      beamGradient.addColorStop(0, 'rgba(255, 255, 0, 0.3)');\n      beamGradient.addColorStop(1, 'rgba(255, 255, 0, 0)');\n      \n      ctx.strokeStyle = beamGradient;\n      ctx.lineWidth = 3 + energy * 10;\n      ctx.globalAlpha = 0.3;\n      ctx.beginPath();\n      ctx.moveTo(sunX, sunY);\n      ctx.lineTo(endX, endY);\n      ctx.stroke();\n      ctx.globalAlpha = 1;\n    }\n  }\n};\n\n// DNA螺旋\ninterface DNANode {\n  x: number;\n  y: number;\n  z: number;\n  color: string;\n  baseColor: string;\n  pairColor: string;\n  size: number;\n  rotation: number;\n}\n\n// DNA效果配置\nlet dnaNodes: DNANode[] = [];\nlet dnaRotation = 0;\n\n// 初始化DNA节点\nconst initDNA = (count: number, startColor: string, endColor: string, pairStartColor: string, pairEndColor: string) => {\n  dnaNodes = [];\n  for (let i = 0; i < count; i++) {\n    // 错开两条链的节点位置\n    const isBase = i % 2 === 0;\n    const zPos = i * 15; // 节点间距\n    \n    // 为每对碱基分配颜色\n    const colorPos = Math.floor(i / 2) / (count / 2);\n    const baseColor = getGradientColor(startColor, endColor, colorPos);\n    const pairColor = getGradientColor(pairStartColor, pairEndColor, colorPos);\n    \n    dnaNodes.push({\n      x: 0,\n      y: 0,\n      z: zPos,\n      color: isBase ? baseColor : pairColor,\n      baseColor,\n      pairColor,\n      size: 8,\n      rotation: 0\n    });\n  }\n};\n\n// DNA螺旋效果\nexport const drawDNAHelix = (\n  ctx: CanvasRenderingContext2D,\n  frequencies: Uint8Array,\n  waveform: Float32Array,\n  width: number,\n  height: number,\n  options: {\n    startColor?: string;\n    endColor?: string;\n    pairStartColor?: string;\n    pairEndColor?: string;\n    rotationSpeed?: number;\n    density?: number;\n    background?: string;\n  } = {}\n) => {\n  const {\n    startColor = '#9c27b0',\n    endColor = '#3f51b5',\n    pairStartColor = '#4CAF50',\n    pairEndColor = '#8BC34A',\n    rotationSpeed = 0.005,\n    density = 1,\n    background = '#000'\n  } = options;\n  \n  // 初始化DNA节点\n  if (dnaNodes.length === 0) {\n    initDNA(70 * density, startColor, endColor, pairStartColor, pairEndColor);\n  }\n  \n  // 清除画布并设置背景\n  ctx.fillStyle = background;\n  ctx.fillRect(0, 0, width, height);\n  \n  // 计算音频能量\n  let energy = 0;\n  for (let i = 0; i < frequencies.length; i++) {\n    energy += frequencies[i] / 255;\n  }\n  energy /= frequencies.length;\n  \n  // 根据音频能量更新旋转\n  dnaRotation += rotationSpeed * (1 + energy);\n  \n  // 3D透视参数\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const perspective = 500;\n  const camZ = 150;\n  const helix = {\n    radius: 50 + energy * 30,\n    pitch: 100 // 螺旋节距\n  };\n  \n  // 对节点按Z坐标排序，实现正确的遮挡效果\n  const sortedNodes = [...dnaNodes].sort((a, b) => b.z - a.z);\n  \n  // 跟踪同一Z位置的两个节点，用于绘制连接线\n  let connectionPairs: {node1: DNANode, node2: DNANode}[] = [];\n  \n  // 分析音频波形用于变形\n  const waveformEnergy = waveform.reduce((sum, val) => sum + Math.abs(val), 0) / waveform.length;\n  \n  // 根据低频能量控制螺旋扭曲\n  let bassEnergy = 0;\n  for (let i = 0; i < 10; i++) {\n    bassEnergy += frequencies[i] / 255;\n  }\n  bassEnergy /= 10;\n  \n  // 更新并绘制DNA节点\n  for (let i = 0; i < dnaNodes.length; i++) {\n    const node = dnaNodes[i];\n    \n    // 将节点位置在螺旋上\n    const isBase = i % 2 === 0;\n    const pairIndex = isBase ? i + 1 : i - 1;\n    const hasPair = pairIndex >= 0 && pairIndex < dnaNodes.length;\n    \n    // 计算螺旋位置\n    const angle = (node.z / helix.pitch) * Math.PI * 2 + dnaRotation;\n    const spiralRadius = helix.radius * (1 + Math.sin(angle * 3 + Date.now() * 0.001) * 0.1 * bassEnergy);\n    \n    // 交错两条链的相位\n    const phaseOffset = isBase ? 0 : Math.PI;\n    \n    // 添加频率数据造成的形变\n    const freqIndex = Math.floor((i / dnaNodes.length) * frequencies.length);\n    const freqValue = frequencies[freqIndex] / 255;\n    \n    // 根据音频数据计算节点的3D位置\n    node.x = Math.cos(angle + phaseOffset) * (spiralRadius + freqValue * 20);\n    node.y = Math.sin(angle + phaseOffset) * (spiralRadius + freqValue * 20);\n    \n    // 增加波形变形\n    const waveOffset = Math.sin(Date.now() * 0.001 + i * 0.1) * waveformEnergy * 30;\n    \n    // 进行视锥透视变换\n    const scale = perspective / (perspective + node.z - camZ + waveOffset);\n    const x2d = centerX + node.x * scale;\n    const y2d = centerY + node.y * scale;\n    \n    // 节点大小根据距离变化\n    const nodeSize = node.size * scale * (1 + freqValue * 0.5);\n    \n    // 保存投影位置用于绘制连接线\n    sortedNodes[i].x = x2d;\n    sortedNodes[i].y = y2d;\n    sortedNodes[i].size = nodeSize;\n    \n    // 如果是一对中的第一个，保存它们的关系用于绘制连接线\n    if (isBase && hasPair) {\n      connectionPairs.push({node1: node, node2: dnaNodes[pairIndex]});\n    }\n  }\n  \n  // 先绘制两条螺旋骨架\n  ctx.lineWidth = 2;\n  ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';\n  \n  // 第一条链\n  ctx.beginPath();\n  let firstNode = true;\n  for (let i = 0; i < sortedNodes.length; i += 2) {\n    const node = sortedNodes[i];\n    if (firstNode) {\n      ctx.moveTo(node.x, node.y);\n      firstNode = false;\n    } else {\n      ctx.lineTo(node.x, node.y);\n    }\n  }\n  ctx.stroke();\n  \n  // 第二条链\n  ctx.beginPath();\n  firstNode = true;\n  for (let i = 1; i < sortedNodes.length; i += 2) {\n    const node = sortedNodes[i];\n    if (firstNode) {\n      ctx.moveTo(node.x, node.y);\n      firstNode = false;\n    } else {\n      ctx.lineTo(node.x, node.y);\n    }\n  }\n  ctx.stroke();\n  \n  // 绘制连接碱基对的线\n  for (const pair of connectionPairs) {\n    const node1 = pair.node1;\n    const node2 = pair.node2;\n    \n    // 计算两点的透视位置\n    const scale1 = perspective / (perspective + node1.z - camZ);\n    const x1 = centerX + node1.x * scale1;\n    const y1 = centerY + node1.y * scale1;\n    \n    const scale2 = perspective / (perspective + node2.z - camZ);\n    const x2 = centerX + node2.x * scale2;\n    const y2 = centerY + node2.y * scale2;\n    \n    // 根据频率数据改变连接线的样式\n    const pairIndex = Math.floor((node1.z / (70 * density * 15)) * frequencies.length);\n    const pairFreq = pairIndex < frequencies.length ? frequencies[pairIndex] / 255 : 0;\n    \n    // 绘制碱基对连接线\n    const gradient = ctx.createLinearGradient(x1, y1, x2, y2);\n    gradient.addColorStop(0, node1.baseColor);\n    gradient.addColorStop(1, node2.pairColor);\n    \n    ctx.strokeStyle = gradient;\n    ctx.lineWidth = 1 + pairFreq * 2;\n    \n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n    \n    // 在高能量时添加发光效果\n    if (pairFreq > 0.7) {\n      ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';\n      ctx.lineWidth = 1;\n      ctx.beginPath();\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y2);\n      ctx.stroke();\n    }\n  }\n  \n  // 最后绘制所有节点\n  for (const node of sortedNodes) {\n    // 在高频能量大时使节点像素化\n    const freqIndex = Math.floor((node.z / (70 * density * 15)) * frequencies.length);\n    const freq = freqIndex < frequencies.length ? frequencies[freqIndex] / 255 : 0;\n    \n    if (freq > 0.8) {\n      // 像素化效果\n      const pixelSize = 2 + freq * 3;\n      for (let px = -2; px <= 2; px++) {\n        for (let py = -2; py <= 2; py++) {\n          if (Math.random() < freq * 0.8) {\n            ctx.fillStyle = node.color;\n            ctx.fillRect(\n              node.x + px * pixelSize, \n              node.y + py * pixelSize, \n              pixelSize, \n              pixelSize\n            );\n          }\n        }\n      }\n    } else {\n      // 正常圆形节点\n      ctx.fillStyle = node.color;\n      ctx.beginPath();\n      ctx.arc(node.x, node.y, node.size, 0, Math.PI * 2);\n      ctx.fill();\n      \n      // 在节点上添加高光\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';\n      ctx.beginPath();\n      ctx.arc(node.x - node.size * 0.3, node.y - node.size * 0.3, node.size * 0.2, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n  \n  // 在高能量时添加辉光效果\n  if (energy > 0.6) {\n    ctx.fillStyle = `rgba(255, 255, 255, ${energy * 0.1})`;\n    ctx.fillRect(0, 0, width, height);\n    \n    // 添加光束\n    for (let i = 0; i < 5; i++) {\n      const beamX = centerX + (Math.random() - 0.5) * width * 0.8;\n      const beamY = centerY + (Math.random() - 0.5) * height * 0.8;\n      \n      const gradient = ctx.createRadialGradient(\n        beamX, beamY, 0,\n        beamX, beamY, 100 * energy\n      );\n      gradient.addColorStop(0, `rgba(255, 255, 255, ${energy * 0.3})`);\n      gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');\n      \n      ctx.fillStyle = gradient;\n      ctx.beginPath();\n      ctx.arc(beamX, beamY, 100 * energy, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n};\n\n// 数字水纹\ninterface Ripple {\n  x: number;\n  y: number;\n  radius: number;\n  maxRadius: number;\n  color: string;\n  opacity: number;\n  speed: number;\n  thickness: number;\n}\n\ninterface DataParticle {\n  x: number;\n  y: number;\n  char: string;\n  color: string;\n  opacity: number;\n  size: number;\n  velocity: { x: number, y: number };\n}\n\n// 存储当前的水纹和数字粒子\nlet ripples: Ripple[] = [];\nlet dataParticles: DataParticle[] = [];\nlet lastRippleTime = 0;\n\n// 创建水纹\nconst createRipple = (posX: number, posY: number, startColor: string, endColor: string, energy: number): Ripple => {\n  const colorPercent = Math.random();\n  const color = getGradientColor(startColor, endColor, colorPercent);\n  const maxRadius = 100 + Math.random() * 150 * energy;\n  \n  return {\n    x: posX,\n    y: posY,\n    radius: 0,\n    maxRadius,\n    color,\n    opacity: 0.8,\n    speed: 1 + Math.random() * 2 * energy,\n    thickness: 2 + Math.random() * 3 * energy\n  };\n};\n\n// 创建数字粒子\nconst createDataParticle = (posX: number, posY: number, startColor: string, endColor: string): DataParticle => {\n  const color = getGradientColor(startColor, endColor, Math.random());\n  const chars = '01';\n  \n  return {\n    x: posX,\n    y: posY,\n    char: chars.charAt(Math.floor(Math.random() * chars.length)),\n    color,\n    opacity: 0.5 + Math.random() * 0.5,\n    size: 10 + Math.random() * 10,\n    velocity: {\n      x: (Math.random() - 0.5) * 2,\n      y: (Math.random() - 0.5) * 2\n    }\n  };\n};\n\n// 数字水纹效果\nexport const drawDigitalRipple = (\n  ctx: CanvasRenderingContext2D,\n  frequencies: Uint8Array,\n  waveform: Float32Array,\n  width: number,\n  height: number,\n  options: {\n    startColor?: string;\n    endColor?: string;\n    density?: number;\n    particleCount?: number;\n    rippleThreshold?: number;\n    background?: string;\n  } = {}\n) => {\n  const {\n    startColor = '#00bcd4',\n    endColor = '#3f51b5',\n    density = 1,\n    particleCount = 100,\n    rippleThreshold = 0.6,\n    background = 'rgba(0, 0, 0, 0.2)'\n  } = options;\n  \n  // 半透明背景，形成拖尾效果\n  ctx.fillStyle = background;\n  ctx.fillRect(0, 0, width, height);\n  \n  // 计算音频能量\n  let energy = 0;\n  for (let i = 0; i < frequencies.length; i++) {\n    energy += frequencies[i] / 255;\n  }\n  energy /= frequencies.length;\n  \n  // 根据低频能量创建水纹\n  let bassEnergy = 0;\n  for (let i = 0; i < 10; i++) {\n    bassEnergy += frequencies[i] / 255;\n  }\n  bassEnergy /= 10;\n  \n  // 创建数字粒子\n  if (dataParticles.length < particleCount * density) {\n    const newParticleCount = Math.floor(particleCount * density) - dataParticles.length;\n    for (let i = 0; i < newParticleCount; i++) {\n      dataParticles.push(createDataParticle(\n        Math.random() * width,\n        Math.random() * height,\n        startColor,\n        endColor\n      ));\n    }\n  }\n  \n  // 在响应大声音时生成新的水纹\n  const now = Date.now();\n  if (bassEnergy > rippleThreshold && now - lastRippleTime > 300 / (density * bassEnergy)) {\n    // 使用波形数据确定水纹位置\n    const waveIndex = Math.floor(Math.random() * waveform.length);\n    const xPos = width * 0.5 + waveform[waveIndex] * width * 0.4;\n    const yPos = height * 0.5 + Math.random() * height * 0.4;\n    \n    ripples.push(createRipple(xPos, yPos, startColor, endColor, bassEnergy));\n    lastRippleTime = now;\n    \n    // 在水纹中心添加额外的数字粒子爆发\n    const burstCount = Math.floor(5 + bassEnergy * 15);\n    for (let i = 0; i < burstCount; i++) {\n      const particle = createDataParticle(xPos, yPos, startColor, endColor);\n      // 爆发速度更快\n      const angle = Math.random() * Math.PI * 2;\n      const speed = 2 + Math.random() * 5;\n      particle.velocity.x = Math.cos(angle) * speed;\n      particle.velocity.y = Math.sin(angle) * speed;\n      dataParticles.push(particle);\n    }\n  }\n  \n  // 更新和绘制水纹\n  ripples = ripples.filter(ripple => {\n    ripple.radius += ripple.speed;\n    ripple.opacity = Math.max(0, ripple.opacity - 0.01);\n    \n    // 只绘制一定不透明度的水纹\n    if (ripple.opacity > 0.05) {\n      ctx.strokeStyle = ripple.color;\n      ctx.lineWidth = ripple.thickness;\n      ctx.globalAlpha = ripple.opacity;\n      \n      // 添加数字化效果\n      const segments = Math.floor(12 + energy * 12);\n      const segmentAngle = (Math.PI * 2) / segments;\n      \n      // 数字化水纹\n      for (let i = 0; i < segments; i++) {\n        // 扭曲各段\n        const freqIndex = Math.floor((i / segments) * frequencies.length);\n        const freqValue = frequencies[freqIndex] / 255;\n        \n        const startAngle = i * segmentAngle;\n        const endAngle = startAngle + segmentAngle;\n        \n        // 扰动半径\n        const radiusVariation = 1 + freqValue * 0.3;\n        \n        ctx.beginPath();\n        ctx.arc(\n          ripple.x, \n          ripple.y, \n          ripple.radius * radiusVariation, \n          startAngle, \n          endAngle\n        );\n        ctx.stroke();\n      }\n      \n      ctx.globalAlpha = 1;\n    }\n    \n    // 当水纹半径超过最大值或不透明度太低时，移除它\n    return ripple.radius < ripple.maxRadius && ripple.opacity > 0.05;\n  });\n  \n  // 更新和绘制数字粒子\n  dataParticles = dataParticles.filter(particle => {\n    // 更新位置\n    particle.x += particle.velocity.x;\n    particle.y += particle.velocity.y;\n    \n    // 如果离开画布，重置到另一边\n    if (particle.x < 0) particle.x = width;\n    if (particle.x > width) particle.x = 0;\n    if (particle.y < 0) particle.y = height;\n    if (particle.y > height) particle.y = 0;\n    \n    // 在水纹附近的粒子受到影响\n    for (const ripple of ripples) {\n      const dx = particle.x - ripple.x;\n      const dy = particle.y - ripple.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      \n      // 当粒子接近水纹边缘时\n      const rippleEdgeDistance = Math.abs(distance - ripple.radius);\n      if (rippleEdgeDistance < 20) {\n        // 增加粒子大小和改变颜色\n        particle.size *= 1.05;\n        \n        // 给粒子加上一个指向或远离水纹中心的力\n        const angle = Math.atan2(dy, dx);\n        const force = 0.2 * (1 - rippleEdgeDistance / 20);\n        particle.velocity.x += Math.cos(angle) * force;\n        particle.velocity.y += Math.sin(angle) * force;\n        \n        // 随机改变字符\n        if (Math.random() < 0.1) {\n          particle.char = Math.random() < 0.5 ? '0' : '1';\n        }\n      }\n    }\n    \n    // 限制粒子速度\n    const speed = Math.sqrt(\n      particle.velocity.x * particle.velocity.x + \n      particle.velocity.y * particle.velocity.y\n    );\n    if (speed > 5) {\n      particle.velocity.x = (particle.velocity.x / speed) * 5;\n      particle.velocity.y = (particle.velocity.y / speed) * 5;\n    }\n    \n    // 缓慢恢复原来的大小\n    particle.size = particle.size * 0.99 + (10 + Math.random() * 10) * 0.01;\n    \n    // 根据频率变化字体大小和字符\n    const freqIndex = Math.floor((particle.x / width) * frequencies.length);\n    const freqValue = frequencies[freqIndex] / 255;\n    \n    if (freqValue > 0.7 && Math.random() < 0.2) {\n      particle.char = Math.random() < 0.5 ? '0' : '1';\n    }\n    \n    // 绘制数字粒子\n    ctx.font = `${Math.floor(particle.size)}px monospace`;\n    ctx.fillStyle = particle.color;\n    ctx.globalAlpha = particle.opacity;\n    ctx.fillText(particle.char, particle.x, particle.y);\n    ctx.globalAlpha = 1;\n    \n    return true;\n  });\n  \n  // 添加闪烁效果\n  const flashCount = Math.floor(energy * 10);\n  for (let i = 0; i < flashCount; i++) {\n    if (Math.random() < 0.3) {\n      const flashX = Math.random() * width;\n      const flashY = Math.random() * height;\n      \n      ctx.fillStyle = getGradientColor(startColor, endColor, Math.random());\n      ctx.font = `${Math.floor(15 + Math.random() * 20)}px monospace`;\n      ctx.fillText(Math.random() < 0.5 ? '0' : '1', flashX, flashY);\n    }\n  }\n  \n  // 在高能量时添加矩阵代码雨效果\n  if (energy > 0.7) {\n    const codeRainCount = Math.floor(10 + energy * 20);\n    \n    for (let i = 0; i < codeRainCount; i++) {\n      const x = Math.random() * width;\n      let y = -20;\n      \n      const columnHeight = Math.floor(5 + Math.random() * 15);\n      const charSize = 12 + Math.random() * 8;\n      \n      for (let j = 0; j < columnHeight; j++) {\n        const charOpacity = 1 - (j / columnHeight);\n        \n        if (charOpacity > 0.1) {\n          ctx.font = `${Math.floor(charSize)}px monospace`;\n          ctx.fillStyle = `rgba(0, 255, 140, ${charOpacity})`;\n          ctx.fillText(Math.random() < 0.5 ? '0' : '1', x, y + j * charSize);\n        }\n      }\n    }\n  }\n};\n\n// 粒子文字\ninterface TextParticle {\n  x: number;\n  y: number;\n  originX: number;\n  originY: number;\n  color: string;\n  size: number;\n  dx: number;\n  dy: number;\n  vx: number;\n  vy: number;\n  force: number;\n  angle: number;\n  distance: number;\n  random: number;\n  alpha: number;\n  brightness: number;\n}\n\n// 存储文字粒子\nlet textParticles: TextParticle[] = [];\nlet particleText = '音楽';\nlet textSize = 80;\nlet textInitialized = false;\n\n// 初始化文字粒子\nconst initTextParticles = (\n  ctx: CanvasRenderingContext2D,\n  text: string,\n  size: number,\n  width: number,\n  height: number,\n  startColor: string,\n  endColor: string\n) => {\n  // 调整文本位置\n  ctx.font = `bold ${size}px Arial`;\n  ctx.textAlign = 'center';\n  \n  // 清除之前的粒子\n  textParticles = [];\n  \n  // 创建临时画布用于获取文本像素\n  const tempCanvas = document.createElement('canvas');\n  const tempCtx = tempCanvas.getContext('2d');\n  \n  if (!tempCtx) return;\n  \n  tempCanvas.width = width;\n  tempCanvas.height = height;\n  \n  // 在临时画布上绘制文本\n  tempCtx.font = `bold ${size}px Arial`;\n  tempCtx.fillStyle = '#ffffff';\n  tempCtx.textAlign = 'center';\n  tempCtx.textBaseline = 'middle';\n  tempCtx.fillText(text, width / 2, height / 2);\n  \n  // 获取像素数据\n  const imageData = tempCtx.getImageData(0, 0, width, height).data;\n  \n  // 采样步长（调整以控制粒子数量）\n  const sampleStep = 4 + Math.floor(size / 30);\n  \n  // 创建文字粒子\n  for (let y = 0; y < height; y += sampleStep) {\n    for (let x = 0; x < width; x += sampleStep) {\n      const index = (y * width + x) * 4;\n      // 只为不透明像素创建粒子\n      if (imageData[index + 3] > 128) {\n        const colorPos = Math.random();\n        const color = getGradientColor(startColor, endColor, colorPos);\n        \n        textParticles.push({\n          x: width / 2 + (Math.random() - 0.5) * width,\n          y: height / 2 + (Math.random() - 0.5) * height,\n          originX: x,\n          originY: y,\n          color,\n          size: 1 + Math.random() * 3,\n          dx: 0,\n          dy: 0,\n          vx: 0,\n          vy: 0,\n          force: 0,\n          angle: 0,\n          distance: 0,\n          random: Math.random(),\n          alpha: 0,\n          brightness: 0\n        });\n      }\n    }\n  }\n  \n  textInitialized = true;\n};\n\n// 粒子文字效果\nexport const drawParticleText = (\n  ctx: CanvasRenderingContext2D,\n  frequencies: Uint8Array,\n  waveform: Float32Array,\n  width: number,\n  height: number,\n  options: {\n    text?: string;\n    startColor?: string;\n    endColor?: string;\n    particleSize?: number;\n    textSize?: number;\n    easeDistance?: number;\n    interactive?: boolean;\n    background?: string;\n  } = {}\n) => {\n  const {\n    text = '音楽',\n    startColor = '#ff4081',\n    endColor = '#7c4dff',\n    particleSize = 2,\n    textSize: customTextSize = 80,\n    easeDistance = 8,\n    interactive = true,\n    background = 'rgba(0, 0, 0, 0.05)'\n  } = options;\n  \n  // 如果文字或大小改变，重新初始化粒子\n  if (!textInitialized || particleText !== text || textSize !== customTextSize) {\n    particleText = text;\n    textSize = customTextSize;\n    initTextParticles(ctx, text, textSize, width, height, startColor, endColor);\n  }\n  \n  // 绘制半透明背景\n  ctx.fillStyle = background;\n  ctx.fillRect(0, 0, width, height);\n  \n  // 计算音频能量\n  let energy = 0;\n  for (let i = 0; i < frequencies.length; i++) {\n    energy += frequencies[i] / 255;\n  }\n  energy /= frequencies.length;\n  \n  // 获取低频能量\n  let bassEnergy = 0;\n  for (let i = 0; i < 10; i++) {\n    bassEnergy += frequencies[i] / 255;\n  }\n  bassEnergy /= 10;\n  \n  // 获取高频能量\n  let highEnergy = 0;\n  for (let i = frequencies.length - 20; i < frequencies.length; i++) {\n    highEnergy += frequencies[i] / 255;\n  }\n  highEnergy /= 20;\n  \n  // 创建鼠标交互的影响\n  const mouseX = width / 2;\n  const mouseY = height / 2;\n  \n  // 根据音频波形创建波动效果\n  const waveX = Math.sin(Date.now() * 0.001) * width * 0.1;\n  const waveY = Math.cos(Date.now() * 0.001) * height * 0.1;\n  \n  // 更新和绘制所有粒子\n  for (let i = 0; i < textParticles.length; i++) {\n    const particle = textParticles[i];\n    \n    // 调整目标位置，添加基于频率的扰动\n    const frequencyIndex = Math.floor((i / textParticles.length) * frequencies.length);\n    const frequencyValue = frequencies[frequencyIndex] / 255;\n    \n    // 根据频率调整粒子的目标位置\n    const targetX = particle.originX + waveX * frequencyValue * 2;\n    const targetY = particle.originY + waveY * frequencyValue * 2;\n    \n    // 计算距离\n    particle.dx = targetX - particle.x;\n    particle.dy = targetY - particle.y;\n    particle.distance = Math.sqrt(particle.dx * particle.dx + particle.dy * particle.dy);\n    \n    // 力的计算\n    particle.force = -easeDistance * (1 - particle.distance / easeDistance);\n    \n    // 如果粒子接近目标位置，减小力\n    if (particle.distance < easeDistance) {\n      particle.force = (particle.distance - easeDistance) * (particle.random * 0.1 + 0.12);\n    }\n    \n    // 计算角度\n    particle.angle = Math.atan2(particle.dy, particle.dx);\n    \n    // 应用力\n    particle.vx += Math.cos(particle.angle) * particle.force;\n    particle.vy += Math.sin(particle.angle) * particle.force;\n    \n    // 添加鼠标/触摸交互\n    if (interactive) {\n      // 计算到鼠标位置的距离\n      const mouseForceRadius = 50 * (1 + bassEnergy);\n      const dx = particle.x - mouseX - waveX * bassEnergy * 10;\n      const dy = particle.y - mouseY - waveY * bassEnergy * 10;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      \n      // 施加鼠标斥力\n      if (distance < mouseForceRadius) {\n        const angle = Math.atan2(dy, dx);\n        const force = (mouseForceRadius - distance) / mouseForceRadius;\n        particle.vx += Math.cos(angle) * force * (1 + bassEnergy * 10);\n        particle.vy += Math.sin(angle) * force * (1 + bassEnergy * 10);\n      }\n    }\n    \n    // 添加随机性\n    particle.vx += (Math.random() - 0.5) * (0.1 + highEnergy * 0.2);\n    particle.vy += (Math.random() - 0.5) * (0.1 + highEnergy * 0.2);\n    \n    // 阻尼\n    particle.vx *= 0.92;\n    particle.vy *= 0.92;\n    \n    // 更新位置\n    particle.x += particle.vx;\n    particle.y += particle.vy;\n    \n    // 计算不透明度（基于到原点的距离）\n    particle.alpha = Math.min(1, 1 - (particle.distance / 200));\n    if (particle.alpha < 0) particle.alpha = 0;\n    \n    // 根据音频数据调整亮度\n    particle.brightness = 0.8 + frequencyValue * 0.5;\n    \n    // 在高能量时添加脉冲效果\n    if (energy > 0.7 && Math.random() < 0.2) {\n      particle.size = particleSize * (1 + Math.random() * 2);\n      particle.brightness = 1.5;\n    } else {\n      // 缓慢恢复原来的大小\n      particle.size = particle.size * 0.95 + particleSize * 0.05;\n    }\n    \n    // 绘制粒子\n    ctx.globalAlpha = particle.alpha;\n    ctx.fillStyle = particle.color;\n    \n    // 根据能量决定是否绘制为圆形或正方形\n    if (energy > 0.6 && Math.random() < 0.3) {\n      // 正方形\n      const size = particle.size * 1.2 * particle.brightness;\n      ctx.fillRect(\n        particle.x - size / 2,\n        particle.y - size / 2,\n        size,\n        size\n      );\n    } else {\n      // 圆形\n      ctx.beginPath();\n      ctx.arc(\n        particle.x,\n        particle.y,\n        particle.size * particle.brightness,\n        0,\n        Math.PI * 2\n      );\n      ctx.fill();\n    }\n    \n    // 高能量时添加连接线\n    if (energy > 0.8) {\n      // 查找临近粒子并连线\n      for (let j = i + 1; j < textParticles.length; j++) {\n        const otherParticle = textParticles[j];\n        const dx = particle.x - otherParticle.x;\n        const dy = particle.y - otherParticle.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        \n        if (distance < 25) {\n          ctx.globalAlpha = (1 - distance / 25) * 0.2 * particle.alpha * otherParticle.alpha;\n          ctx.strokeStyle = particle.color;\n          ctx.lineWidth = 0.5;\n          ctx.beginPath();\n          ctx.moveTo(particle.x, particle.y);\n          ctx.lineTo(otherParticle.x, otherParticle.y);\n          ctx.stroke();\n        }\n      }\n    }\n  }\n  \n  // 重置全局透明度\n  ctx.globalAlpha = 1;\n  \n  // 添加整体模糊效果\n  if (energy > 0.5) {\n    ctx.fillStyle = `rgba(0, 0, 0, ${0.05 * energy})`;\n    ctx.fillRect(0, 0, width, height);\n  }\n  \n  // 在高能量时添加闪烁效果\n  if (energy > 0.7) {\n    for (let i = 0; i < 10; i++) {\n      if (Math.random() < 0.2) {\n        const x = Math.random() * width;\n        const y = Math.random() * height;\n        const size = 1 + Math.random() * 3;\n        \n        ctx.fillStyle = getGradientColor(startColor, endColor, Math.random());\n        ctx.beginPath();\n        ctx.arc(x, y, size, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n  }\n};\n\n// 注释掉新添加的效果类型\nenum VisualizationType {\n  SPECTRUM_BARS = 'spectrumBars',\n  WAVEFORM = 'waveform',\n  CIRCULAR = 'circular',\n  PARTICLES = 'particles',\n  KALEIDOSCOPE = 'kaleidoscope',\n  AUDIO_WATERFALL = 'audioWaterfall',\n  ORGANIC_FORM = 'organicForm',\n  TETRIS = 'tetris',\n  LIP_SYNC = 'lipSync',\n  // 暂时注释掉新添加的效果\n  // MUSIC_METEOR = 'musicMeteor',\n  // SOUND_GARDEN = 'soundGarden',\n  // DNA_HELIX = 'dnaHelix',\n  // DIGITAL_RIPPLE = 'digitalRipple',\n  // PARTICLE_TEXT = 'particleText'\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}